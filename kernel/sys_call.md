---
author: lunar
date: Wed 21 Oct 2020 02:11:02 PM CST
---

## 系统调用

### 系统调用

#### 系统调用号

在 Linux 中，每个系统调用被赋予了一个系统调用号。当用户空间的进程执行一个系统调用时，这个系统调用号就用来指明到底是执行哪个系统调用，进程不会关系系统调用的名称。

内核记录了系统调用表中所有已经注册过的系统调用的列表，存储在 sys_call_table 中。在 x86-64中，它定义在 arch/i386/kernel/syscall_64.c中。

### 系统调用处理程序

我们知道，用户空间的代码无法直接执行内核代码，因为内核停留在受保护的内核空间中。所以应用程序在进程系统调用时需要通过系统自己需要执行一个系统调用以便自己能够切换到内核空间中。

通知内核的机制是通过软中断实现的：通过引发一个异常来促使系统切换到内核态去执行异常处理程序。

#### 指定恰当的系统调用

因为所有的系统调用陷入内核的方式都是一样的，所以必须把系统调用号一并传给内核。在x86中，系统调用号是通过 eax 寄存器传递给内核的。在陷入内核之前，用户空间就把相应系统调用所对应的号放在 eax 中。这样内核就可以从该寄存器中得到系统调用号。

#### 参数传递

除了系统调用号之外，大部分系统调用还需要传入一些参数。

在 x86-32 系统上，存在5个寄存器用来存放前5个参数。如果存在6个及以上的参数，则应该用一个单独的寄存器存放指向这些参数的用户空间地址的指针。

### 系统调用的实现

#### 参数验证

系统调用必须仔细检查它们的参数是否有效，否则内核的安全将面临极大的考验。

最重要的一类检查就是检查用户提供的指针是否有效。在接收一个用户空间的指针之前，内核必须保证：

-   指针指向的内存区域属于用户空间，且属于该进程的地址空间；
-   不管是读、写还是执行，都需要检查相应的内存访问权限。

### 系统调用上下文

我们知道，内核在执行系统调用的时候处于进程上下文，current指针指向当前任务，即引发系统调用的那个进程。

在进程上下文中，内核可以休眠并且可以被抢占。

#### 绑定一个系统调用的最后步骤

在编写完一个系统调用后，把它注册为一个正式的系统调用需要以下步骤：

1.  在sys_call_table的最后加入一个表项。从0开始算起，系统调用在该表中的位置就是它的系统调用号；

2.  对于所支持的各种体系结构，系统调用号都必须定义于 \<asm/unistd.h\> 中。

    比如，定义一个新的系统调用foo，其分配到的系统调用号为 338，则在该文件中添加

    ```c
    #define __NR_foo 338
    ```

3.  系统调用必须被编译进系统映像，这只要把它放进kernel/下的一个相关文件就可以了。

#### 从用户空间访问系统调用

Linux本身提供了一组宏，用于直接对系统调用进行访问。这些宏是 \_syscall*n*()，其中 *n* 的范围是0到6，代表需要传递给系统调用的参数个数。

```c
#define __NR_foo 386
__syscall0(long, foo)
```

