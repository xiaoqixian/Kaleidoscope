---
author: lunar
date: Sat 17 Oct 2020 03:42:45 PM CST
---

## 进程管理与调度

主要内容包括：
$$
\begin{cases}进程的概念\begin{cases}进程的数据结构\\进程的创建\\进程与线程的区别\\进程的状态\begin{cases}运行态\\就绪态\\阻塞态 \end{cases} \end{cases} \\进程间的通信\begin{cases}互斥量\\睡眠与唤醒(生产者-消费者问题)\\管道通信\\共享内存\\信号\\消息队列 \end{cases}\\进程的调度方法 \begin{cases}批处理\begin{cases}先到先服务 \mathrm{FIFO}\\最短作业优先\\最短剩余时间优先 \end{cases}\\交互式\begin{cases}轮转调度\\优先级调度\\多级队列\\最短进程优先 \end{cases}\\实时\\线程调度 \begin{cases}线程的上下文切换 \end{cases}\end{cases}\\经典\mathrm{IPC}问题\begin{cases}哲学家就餐问题\\读者-写者问题\end{cases}\end{cases}
$$

### 进程

#### 进程的创建

在UNIX系统中，只有一个系统调用可以用来创建线程：fork。这个系统调用会创建一个与调用相同的副本，父进程和子进程拥有着相同的内存映像、相同的环境字符串和同样的打开文件。之后子进程再通过execve或类似的系统调用来修改其内存映像以执行新的程序。

在UNIX和windows中，进程创建之后，父进程和子进程拥有不同的地址空间。在UNIX中，两者不可写的内存是共享的。或者说，子进程共享父进程的所有内存，但这种情况下内存通过写时复制共享，一旦两者之一想要修改部分内存，则这块内存首先被明确地复制。

#### 多道程序设计模型

从概率的角度来看CPU的利用率，假设一个进程等待IO操作的时间与其停留在内存中的时间比为p，当内存中同时存在n个进程，则、
$$
\mathrm{CPU}利用率 = 1-p^n
$$

#### 用户级线程和内核级线程

![image-20201017161704354](https://raw.githubusercontent.com/xiaoqixian/Tiara/master/img/image-20201017161704354.png)

用户级线程特点：

-   调度不需要内核参与
-   同一个进程内只能有一个线程运行，如果有一个线程被阻塞，则整个进程的线程都被挂起
-   不能利用CPU的多核心优势

内核级线程特点：

-   调用时需要经过用户态-内核态-用户态的转换
-   内核级线程只有很小的数据结构和堆栈，切换速度快
-   下一个调度的线程既可以是同一进程的其它线程，也可以是其它进程的线程。

在Linux2.4版本以后，通过pthread_create创建的线程都是内核级线程。因为在其内部实行了一个系统调用。

由于在内核中创建或撤销线程的代价较大， 某些系统采用“环保”的方式来回收线程。不会销毁线程的数据结构，直接标记为不可运行，下一次创建线程时直接将该数据结构赋予其，然后修改一些值就可以了。

### 进程调度算法

