# !/usr/bin/env python3
# -*- coding: utf-8 -*-
# > Author     : lunar
# > Email       : lunar_ubuntu@qq.com
# > Create Time: Fri 11 Sep 2020 09:40:53 AM CST

"""
/*
 * 代码原理:
 * 由于任意两座矿山之间的最短路径是确定的, 所以我们可以将地图上所有的矿山转化为图的节点, 两座矿山之间的路径可以看做图的边.
 * 起点和终点可以看做是两座收益为0的矿山.
 *
 * 这样第一题就转化成了3个小问题:
 * 1. 如何求得两座矿山之间的最短路径.
 * 2. 在每座矿山中逗留的最优时间
 * 3. 如何权衡在多座矿山之间的逗留问题.
 *
 * 问题1:
 *     采用Dijkstra算法, 可以找到地图中任意两个节点的最短距离. 返回消耗资源和所用的时间.
 * 问题2:
 *     在每座矿山逗留的时间并不等于在矿山待的收益最长的时间, 在一个矿山待的时间会影响接下来的行程消耗.
 *     所以这个问题的确定比较困难, 在矿山数量比较少的情况下, 我们可以将其转化为一个线性规划类型的问题.
 *     这个线性规划问题如果需要确定目标函数的话, 需要将路线确定, 这样才可以确定矿山之间的路途损失.
 *     所以我们需要将所有矿山之间的路线遍历一遍.
 *
 * 线性规划问题:
 *     通过变量x_i来表示在矿山i逗留的时间.
 *     则可以确立目标函数:
 *     max f = \sum_{k=i}^{x_i}G(k) - \sum_{k=0}^{T}L(k)
 *     参数解释:
 *         G(k): 第k天可以在矿山获得的收益
 *         L(k): 第k天的消耗量
 */
"""

# 使用scipy库进行线性规划求解
from scipy import optimize

map = [
    [0,0],# 为了避免从0开始, 无用
    [2,25],
    [1,3],
    [2,4,25],
    [3,5,24,25],
    [4,6,24],
    [5,24,23,7],
    [6,22,8],
    [7,22,9],
    [8,22,21,17,16,15,10],
    [9,15,13,11],
    [10,13,12],
    [11,13,14],
    [11,12,14,10,15],
    [13,12,15,16],
    [9,10,13,14,16],
    [17,18,9,15,14],
    [21,9,16,18],
    [19,20,17,16],
    [18,20],
    [19,18,21],
    [20,18,17,9,22,23,27],
    [21,9,8,7,23],
    [22,6,24,26,21],
    [23,6,5,4,25,26],
    [24,4,3,1,26],
    [25,24,23,27],
    [21,26]
]

waether = [
    0,2,2,1,3,1,2,3,1,2,2,3,2,1,2,2,2,3,3,2,2,1,1,2,1,3,2,1,1,2,2
]

cost_matrix1 = [
    [0,0],
    [25,70],
    [40,60],
    [50,100]
]

mines = [12]
AREA_NUM = 27
LONGEST = AREA_NUM # 最长距离, 不可能有两个区域之间的距离比这个长

# 求解任意map上任意两个节点之间的最短距离的函数
# 返回两个节点之间需要经过的地区数量
# 采用Dijkstra算法
def cal_min_distance(start, end):
    dist = [LONGEST for i in range(AREA_NUM+1)]
    dist[start] = 0
    viewed_num = AREA_NUM - 1
    viewed = [False for i in range(AREA_NUM+1)]
    viewed[start] = True
    min_dis = LONGEST
    min_dis_node = -1
    while viewed_num:
        connections = map[start]
        # 更新距离表
        for node in connections:
            if dist[start] + 1 < dist[node]:
                dist[node] = dist[start] + 1
        # 找到距离表中的最短距离
        min_dis = LONGEST
        min_dis_node = -1
        for i in range(1, len(dist)):
            if not viewed[i] and min_dis > dist[i]:
                min_dis = dist[i]
                min_dis_node = i
        viewed[min_dis_node] = True
        viewed_num -= 1
        start = min_dis_node
        if min_dis_node == end:
            return dist[min_dis_node]
    return dist[min_dis_node]

# 现在考虑动态规划是否可行
# 一般地图类动态规划都是将地点作为阶段划分的因素, 到达某个地点的最优解是什么.
# 然后接下来的最优解就只需要以这个最优解作为跳板求得
# 但是这个题目有一个时间的因素, 一个地点的最优解是随着到达时间的变化而变化的.
# 而前面的最优解会挤压后面的最优解, 两个最优解之间并不算完全独立的.
# 所以只有时间是不变的, 前15天的最优解加上后15天的最优解就是全局的最优解.
#

# 划掉
# 对于第一关, 只有一座矿山, 也就只有两条可选路线. 去, 或者不去.
# 确定好路线后, 接下来确立一个整数规划模型.
# 对于沿途的每一个区域, 用x_{k_i}表示在k_i区域停留的天数
# 如果不去矿山, 第一条路线需要经过: 1 -> 25 -> 26 -> 27
# min f = \sum_{i=1}^{x_1}w(i) + 2 w(x_1 + 1) + \sum_{i=x_1+2}^{x_{25}}w(i) + 2w(x_1 + 1+x_{25}+1) +
def ip():


# cal_min_distance函数测试
if __name__ == '__main__':
    print("起始点1 到 12号矿山的最短距离为:", cal_min_distance(1, 12))
