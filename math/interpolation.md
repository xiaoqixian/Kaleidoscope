---
author: lunar
date: Mon 17 Aug 2020 09:55:30 AM CST
---

### **常见的插值算法**

插值算法常用于扩充数据集。对于数据点很少的一段区间，可以通过拟合一个函数来扩充数据点。（样本多的时候常用拟合算法）

常见的插值算法包括
- 一般多项式插值法
- 拉格朗日插值法
- 牛顿插值法

#### 一般多项式插值法

原理：设有n+1个互不相同的节点$(x_i,y_i)$,则存在**唯一**的多项式：
$$
L_n(x) = a_0 + a_1x + a_2x^2 + ... + a_nx^n\tag{1}
$$
使得$ L_n(x_j) = y_j\quad (j = 0,1,2,...,n)$

若将已知的n+1个节点代入上述$L_n(x)$，则可以得到一个有n+1个方程的方程组。n+1个方程足以解出所有$a_i$

通过矩阵求逆就可以快速求出。

#### 拉格朗日插值法

对于n个已知点$(x_i, y_i)$

在未知点x处的观测值为：
$$
\omega(x_k) = (x_k-x_1)...(x_k-x_{k-1})(x_k-x_{k+1})...(x_k-x_n)\\
f(x) = \sum_{k=1}^n y_k\frac{\prod_{i=1}^n(x-x_i)}{(x-x_i)\omega(x_i)}
$$

#### 牛顿插值法

牛顿插值法非常适合用递归法来做。

规定，函数*f(x)*的关于点$x_0, x_k$的一阶差商为：
$$
f[x_0, x_k] = \frac{f(x_k) - f(x_0)}{x_k-x_0}
$$

二阶差商为：
$$
f[x_0, x_1, x_2] = \frac{f[x_0, x_2] - f[x_0, x_1]}{x_2-x_1}
$$

k阶差商为：
$$
f[x_0, x_1,...,x_k] = \frac{f[x_1,...,x_{k-1},x_k] - f[x_0,...,x_{k-1}]}{x_k-x_0}
$$

则可以推知未知点x处的观测值为：
![](https://bkimg.cdn.bcebos.com/pic/aa64034f78f0f736b42da9d00655b319eac4130b?x-bce-process=image/watermark,image_d2F0ZXIvYmFpa2U5Mg==,g_7,xp_5,yp_5)

相比与拉格朗日插值法，牛顿插值法最大的特点是可以利用前面已经计算好的结果。可以减少计算。

牛顿插值法的缺点：龙格现象。

牛顿插值法和拉格朗日插值法的缺点：这两种插值法仅仅满足在插值节点与被插函数有相同的函数值。然而在许多实际问题中，不仅要求被插值函数与插值函数在所有节点处有相同的函数值，同样需要在一个或全部节点上插值多项式与被插函数有相同的低阶甚至高阶导数值。这两种插值法均不能满足。

#### 龙格现象

当函数的次数过高时，$x_i$削微的变化也会引起函数值巨大的变化。

为了解决这个现象，可以引入分段插值。

#### 分段二次插值

选取距离节点x最近的三个节点$x_{i-1},x_i,x_{i+1}$进行二次插值。

#### 埃尔米特(Hermite)插值

埃尔米特插值用于解决导数相同的问题。

$$
R(x) = f(x) - H(x) = \frac{f^{(2n+2)}(\varepsilon)}{(2n+2)!}\omega_{2n+2}(x)\\
\omega_{2n+2}(x) = \sum_{i=0}^{2n+1}(x-x_i)
$$


