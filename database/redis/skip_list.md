---
author: lunar
date: Thu 06 Aug 2020 02:39:09 PM CST
---

### **Redis跳跃表**

跳跃表是一种可以与平衡树匹配的层次化数据结构，其查找、删除、添加等操作都可以在对数级的期望时间内完成。

有序集合的内部实现就依赖于跳跃表。

#### 为什么有序集合要使用跳跃表

首先，zset要求支持随机的删除和添加元素，因此肯定不能用数组。同时，为了保留查找性能，只能使用平衡树或者红黑树。但是这些树结构要经常进行Rebalance的操作，影响到整棵树。相比之下，跳跃表只需要修改局部。

#### 跳跃表基本思想

跳跃表的基本思想非常类似于二分查找，但是常规的二分查找仅仅适用于排序后的数组。因此，要创建一个链表层面的二分查找。

因此，如下图这样，我们在两个相邻节点就再创建一个指针。这样查找时，就只需要每相邻两个节点之间进行查找一遍，找到对应区间后再在具体两个节点之间进行查找。

![](https://camo.githubusercontent.com/823c190630fedcbc671da76ae63c6fe2062acb8f/68747470733a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f373839363839302d386361653263323631633935306233322e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430)

这个是一个简单的情况，查找的时间只是缩减到原来的一半，并不是对数级时间。于是我们考虑再在每4个节点之间插入指针，每8个节点之间插入指针。这样查找就正式变成了二分查找。

#### 删除和添加的问题

查找性能的问题是解决了，但是添加和删除会使得这种严格上一层和下一层指针数量为1:2的关系改变。

因此为了避免这一问题，跳跃表决定使用随机层数。什么意思呢？即每个节点指向其它节点的指针数量是随机的。

如果随机层数是1，则只指向前面那个节点。如果是2，则指向前面两个节点。其它以此类推。

下图展示了如何一步步通过插入操作形成一个跳跃表：

![](https://camo.githubusercontent.com/c70eab4a050b19421f32b9e1a5ec982b96615f2b/68747470733a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f373839363839302d316530363236633031336465303935652e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430)

同时，说是随机，但是随机数的范围肯定是跟随跳跃表的大小动态变化的。否则层数太高反而会降低效率。

考虑一种极端的情况，如果有序集合所有的元素的分数都相同，是否查找复杂度就是O(n)？

不是，因为在插入节点时，跳跃表会首先比较分数，再比较字符串的值。也就是说分数相同的元素是按字典序排列的。

