---
author: lunar
date: Thu 06 Aug 2020 05:13:21 PM CST
---

### HyperLogLog解决统计问题

HyperLogLog是由Flajolet及其同事提出的一种**估算基数的近似最优算法**。

#### 基于基数统计

基数统计（Cardinality Counting）通常用于统计一个集合中不重复的元素个数（此集合非不包含重复元素的集合）。

#### 基数统计的常用方法

1. B树

   B树存储和查找的效率都非常高，在统计用户数量之前只需要在B树中插入相应用户节点。然后统计一下B树节点数量就可以了。

2. bitmap

#### HyperLogLog原理

上面提到的两种算法都属于精确算法，而HyperLogLog是一种概率算法，只能计算一个集合中非重复元素的大致数量，并且将误差控制在非常小的范围内。

那么它到底是怎么做到的呢？

首先对于集合内的所有元素，我们对其进行哈希化，变成一个位数相同的0和1组成的二进制数串。接着我们需要认识到，由于哈希的随机性，对于集合内的任意一个字符串，其在任意位出现0和1的概率都是相同的。

我们将一个哈希字符串的每一位看成扔一次硬币，硬币服从0-1分布。则扔k次才出现硬币正面向上（即对应位为1）的概率为：
$$
P(X\le k) = 1-\frac1{2^k}
$$
我们把不停地扔硬币，直到出现一次正面向上的过程称为一次**伯努利过程**。

则我们进行n次伯努利过程，所有投掷次数都不大于k的概率为：
$$
P_k(X\le k) = \left(1-\frac1{2^k} \right)^n
$$
同样，进行n次伯努利过程，至少有一次投掷次数等于k的概率为：
$$
P_k(X\ge k) = 1- \left(1-\frac1{2^k} - 1\right)^n
$$
当$n >> 2^k$时，$P(X\le k)$的概率几乎为0。当$n<<2^k$时，$P(X\ge k)$的概率几乎为0。则对于一个集合的所有哈希字符串的最大的k，n即为集合中不重复元素的个数。由于两边的概率都几乎为0。**所以我们可以得出$n = 2^k$的这样的一个粗糙估计。**这一点正是HyperLogLog的精髓。