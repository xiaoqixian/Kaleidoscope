---
author: lunar
date: Sun 09 Aug 2020 09:21:55 PM CST
---

### **Redis数据持久化**

Redis中的两种持久化方式：快照，AOF

#### 快照

快照是最简单的持久化模式。当满足特定条件时，它将生成数据集的时间点快照。这个条件由配置文件来指定。快照作为包含整个数据集的单个`.rdb`文件生成。

但是Redis是单线程的程序，意味着如果经常进行拖时间的IO操作将会严重降低性能。并且在持久化的同时，内存的数据结构还在不断变化。比如一个大型的 hash 字典正在持久化，结果一个请求过来把它删除了，可是这才刚持久化结束，咋办？

**使用系统多进程COW(Copy On Write)机制|fork函数**

操作系统多进程COW机制使得redis在持久化时会调用`glibc`的`fork`函数产生一个子进程，主进程和子进程会共享内存里的代码块和数据段。

所以快照持久化就完全交给子进程进行处理，父进程则继续处理客户端请求。由于父进程会不断修改内存中的数据结构，所以共享内存的问题还是没有解决。

这时候就会使用操作系统的COW机制来进行数据段页面的分离。数据段由很多操作系统的页面组合而成，当父进程对其中一个页面的数据进行修改时，被共享的页面将被复制一份出来，然后对这个复制的页面进行修改。在子进程看来，数据页面是没有变化的。

所以在子进程诞生的那一刻起，其看到的数据就不会变化了，这就是为什么称为「快照」的原因。

#### AOF(Append Only File - 仅追加文件)

AOF的工作方式非常简单：每次执行修改内存的数据集的写操作时，都会记录该操作。如果AOF日志记录了redis创建以来的所有修改记录，那么就可以创建一个新的redis实例，然后按照顺序依次执行这些修改，来回复redis当前实例的状态。也就是「重放」。

#### **AOF重写**

redis在长期允许的过程中，日志会变得越来越长。如果实例宕机，重放整个AOF日志会非常耗时，所以需要进行AOF瘦身。

为此，redis提供了`bgrewriteaof`指令来进行瘦身。其原理就是开辟一个新的子进程对内存进行遍历转成一系列的操作指令，序列化到一个新的AOF日志文件中，序列化完毕后再将操作期间发生的增量AOF日志追加到这个新的AOF日志文件中，追加完毕后就立即替代旧的AOF日志文件，瘦身就完成了。

#### Redis4.0 混合持久化

将`rdb`文件和增量的AOF日志文件存放在一起。这里的AOF日志不再是全量的日志，而是自持久化开始到持久化结束的这段时间发生的增量AOF日志，通常这部分日志很小。

于是在redis重启的时候，可以先加载`rdb`文件的内容，然后再重放AOF日志就可以完全替代之前的AOF全量文件重放，大大加快重启速度。

