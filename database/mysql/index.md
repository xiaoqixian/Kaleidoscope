### **MySQL索引原理及查询优化**

索引在MySQL中也叫做“键”，是存储引擎用于快速找到记录的一种数据结构。索引优化是对查询性能优化最有效的手段。

**索引的本质就是通过不断地所缩小想要获取数据的范围来筛选出最终想要的结果。**

#### 索引的数据结构

由于磁盘IO的代价非常昂贵，所以索引就要求将每次磁盘IO次数控制在一个很小的数量级，最好是常数级。于是B+树应运而生。

![](https://github.com/xiaoqixian/JavaGuide/blob/master/media/pictures/database/B+树.png)

如图就是B+树，每个节点可以存储两个索引，三个指向其它索引的索引，以及一个磁盘块。B+树存储时，位于两个索引中间的索引就放在中间的索引，否则放在两边。这样，如果想要查找第三层的磁盘块，就只要进行三次磁盘IO操作。

**B树与B+树的区别**

B树的所有节点既存放键又存放数据；而B+树只有叶子节点存放数据。

所以B树的查找如同二分查找，可能还没有到叶子节点查找就结束了。

而B+数因为数据总是在底层，所以查找效率总是稳定的。

#### 索引分类

1. 普通索引index：加速查找

2. 唯一索引

   1. 主键索引：加速查找+约束（唯一且不为空）
   2. 唯一索引：加速查找+约束（唯一）

3. 联合索引

   primary key(id, name)：联合主键索引

   unique(id, name)：联合唯一索引

   index(id, name)：联合普通索引

4. 前缀索引

   前缀索引只适用与字符串类型的数据。前缀索引是对于文本的前几个字符建立索引，相比于普通索引，占用的空间更小。

5. 全文索引

   fulltext：用于搜索长文时，效果最好。

6. 二级索引（辅助索引）

   二级索引的叶子节点存储的数据是主键。也就是说，通过二级索引，可以定位主键的位置

   唯一索引，普通索引，前缀索引等索引属于二级索引。

举例：

```sql
1 举个例子来说，比如你在为某商场做一个会员卡的系统。
 2 
 3 这个系统有一个会员表
 4 有下列字段：
 5 会员编号 INT
 6 会员姓名 VARCHAR(10)
 7 会员身份证号码 VARCHAR(18)
 8 会员电话 VARCHAR(10)
 9 会员住址 VARCHAR(50)
10 会员备注信息 TEXT
11 
12 那么这个 会员编号，作为主键，使用 PRIMARY
13 会员姓名 如果要建索引的话，那么就是普通的 INDEX
14 会员身份证号码 如果要建索引的话，那么可以选择 UNIQUE （唯一的，不允许重复）
15 
16 #除此之外还有全文索引，即FULLTEXT
17 会员备注信息 ， 如果需要建索引的话，可以选择全文搜索。
18 用于搜索很长一篇文章的时候，效果最好。
19 用在比较短的文本，如果就一两行字的，普通的 INDEX 也可以。
20 但其实对于全文搜索，我们并不会使用MySQL自带的该索引，而是会选择第三方软件如Sphinx，专门来做全文搜索。
21 
22 #其他的如空间索引SPATIAL，了解即可，几乎不用

各个索引的应用场景
```

#### 索引的两大类型

索引包括哈希和btree两大类型

hash类型的索引：单条查找快，但是多条查找等于是多个单条查找的时间之和。

btree类型的索引：b+树的查找时间与层数有关，但是往往索引相近的都在同一层，所以btree的范围查找更快。

#### 创建/删除索引的语法格式

```sql
1 #方法一：创建表时
 2     　　CREATE TABLE 表名 (
 3                 字段名1  数据类型 [完整性约束条件…],
 4                 字段名2  数据类型 [完整性约束条件…],
 5                 [UNIQUE | FULLTEXT | SPATIAL ]   INDEX | KEY
 6                 [索引名]  (字段名[(长度)]  [ASC |DESC]) 
 7                 );
 8 
 9 
10 #方法二：CREATE在已存在的表上创建索引
11         CREATE  [UNIQUE | FULLTEXT | SPATIAL ]  INDEX  索引名 
12                      ON 表名 (字段名[(长度)]  [ASC |DESC]) ;
13 
14 
15 #方法三：ALTER TABLE在已存在的表上创建索引
16         ALTER TABLE 表名 ADD  [UNIQUE | FULLTEXT | SPATIAL ] INDEX
17                              索引名 (字段名[(长度)]  [ASC |DESC]) ;
18                              
19 #删除索引：DROP INDEX 索引名 ON 表名字;

创建/删除索引的语法
```

#### 聚集索引和非聚集索引

聚集索引即索引结构和数据一起存放的索引。主键索引属于聚集索引。

**聚集索引的优点**：查询速度非常快，定位到索引的节点就相当于定位到了数据。

**聚集索引的缺点**：

1. 依赖于有序的数据

   因为B+树是多路平衡树，如果索引的数据不是有序的，那么就需要在插入时排序，如果数据是整型还好，否则类似于字符串或UUID这种又长又难比较的数据，插入或查找的速度肯定比较慢。

   这也是非聚集索引的缺点。

2. 更新代价大

   如果对索引列的数据进行修改，那么对应的索引也会被修改，而且聚集索引的叶子节点还存放着数据，修改的代价肯定是大的。所以对于主键索引来说，主键一般是不可修改的。

非聚集索引即索引结构与数据分开存放的索引。二级索引就属于非聚集索引。

除非正好查询的字段就是索引字段，否则很大可能是需要回表查询的，这就是非聚集查询最大的缺点了。

#### 正确地使用索引

1. 覆盖索引

   #分析
   `select * from s1 where id=123;`
   该sql命中了索引，但未覆盖索引。
   利用id=123到索引的数据结构中定位到该id在硬盘中的位置，或者说再数据表中的位置。
   但是我们select的字段为*，除了id以外还需要其他字段，这就意味着，我们通过索引结构取到id还不够，
   还需要利用该id再去找到该id所在行的其他字段值，这是需要时间的，很明显，如果我们只select id，
   就减去了这份苦恼，如下
   `select id from s1 where id=123;`
   所以我们称一个索引如果包含了所有需要查询的字段为**覆盖索引**。命中索引，且从索引的数据结构直接就取到了id在硬盘的地址，速度很快。
   
2. 联合索引

   对于需要经常联合查询的两个字段或多个字段，可以考虑添加联合索引，对于查询速度有质的飞跃。

3. 索引合并

   组合索引：`create index ne on s1(name, email);`

   索引合并：

   `create index b on s1(email);`

   `create index c on s1(name);`

   索引合并后可以命中更多的情况，但是效率低于组合索引。

#### 索引使用原则

1. 最左前缀匹配原则


      `create index ix_name_email on s1(name,email,);`

      最左前缀匹配：必须按照从左到右的顺序匹配
      `select * from s1 where name='egon';` #可以
      `select * from s1 where name='egon' and email='asdf';` #可以
      `select * from s1 where email='alex@oldboy.com';` #不可以
      mysql会一直向右匹配直到遇到范围查询(>、<、between、like)就停止匹配，
      比如a = 1 and b = 2 and c > 3 and d = 4 如果建立(a,b,c,d)顺序的索引，
      d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。

2. = 和 in可以乱序，比如`a = 1 and b = 2 and c = 3`建立`(a,b,c)`索引可以任意顺序

3. 尽量选择区分度高的列作为索引

   区分度的计算公式为：`count(distinct col)/count(*);`

   唯一键的区分度是1

#### 索引无法命中的情况

1. `like '$xx'`

2. 使用函数

3. `or`

   注意：只有当or的列中有未建立索引的列时，才会失效。如果所有列都有索引的话还是会走索引。

4. 类型不一致

5. **普通索引**的`!=`不会走索引

   特别的：如果是主键或者索引是整数类型，则还是会走索引

6. 排序时，如果排序条件为索引，则select的字段必须也是索引，否则无法命中。

7. 组合索引要满足最左前缀才会走索引

