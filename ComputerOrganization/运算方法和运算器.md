# 运算方法和运算器

### 数的表示方法

#### 定点数和浮点数

所谓定点数，即约定机器中所有数据的小数点位置是固定不变的，通常用于表示**纯小数**或**纯整数**。

对于 $n+1$ 位，第0位表示符号的定点数。

如果表示小数，表示范围为
$$
0\le |x|\le 1-2^{-n}
$$
如果表示整数，表示范围为
$$
0\le |x|\le 2^n-1
$$
浮点数的表示方法是这样的：把数的有效数字和范围在一个存储单元中分别表示，由于有效数字的小数点随着范围的不同而自由浮动，所以称为浮点数。

在计算机中，一个任意进制数可以写成
$$
N = R^E\cdot M
$$
其中$M$ 称为浮点数的**尾数**，是一个纯小数；$E$ 是比例因子的指数，称为浮点数的**阶码**，是一个整数。一般规定 $R$ 为2,8或16.

常用的浮点数格式由高位到低位为：

| $M_0$ | $E_1E_2\cdots E_m$ | $M_1M_2\cdots M_n$ |
| :---: | :----------------: | :----------------: |
|  1位  |        m位         |        n位         |

例如对32位的短实数，1位符号位，阶码8位，尾数23位；对64位的长实数，1位符号位，阶码11位，尾数52位。

#### 十进制数串的表示方法

1. 字符串形式
2. 压缩的十进制数串形式：用每2个bit表示一个数位

### 原码、补码、反码和移码

接下来要介绍的几种码主要为了方便数的运算，将符号位与数位一起编码来进行运算。设考虑的数为 n+1 位，n位为数位。

注意下面所有的加法运算均表示相应位的异或运算，所以+和-没有区别。

#### 原码

小数
$$
[x]_原 = \begin{cases}x \ \ \mathrm{if\ positive}\\1-x\ \ \ \mathrm{if\ negative} \end{cases}
$$
整数
$$
[x]_原 = \begin{cases}x\ \mathrm{if\ positive}\\ 2^n -x\ \ \mathrm{if\ negative} \end{cases}
$$

#### 补码

补码是一种将减法转化为加法的编码。

对于小数
$$
[x]_补 = \begin{cases}x\\ 2+x \end{cases}
$$
对于整数
$$
[x]_补 = \begin{cases}x\\ 2^{n+1}+x =2^{n+1}-|x|\end{cases}
$$
正数减去另一个正数时，可以将减数符号位取1然后求补码，然后再被减数与补码相加。

然而求补码本身就包含了一次减法，所以我们需要用到反码来求补码。

#### 反码

反码就是符号位不变，然后数位全部取反。在计算机中用触发器寄存数码，若触发器右边输出原码，则左边输出反码，因此非常容易获得。

对于小数
$$
[x]_反 = \begin{cases}x\\(2-2^{-n})+x\end{cases}
$$
对于整数
$$
[x]_反 = \begin{cases} x\\(2^{n+1}-1)+x\end{cases}
$$
由反码求补码的方法：对于负数，符号位置1, 其他位取反，再加1。

有了反码和补码，我们就可以计算加减法了。

对于任意两个数，先求两个数的补码，然后将两个 $n+1$ 位的补码看作两个无符号数进行计算，即使最高位溢出也没有关系。

**值得注意的是**，通过补码计算出来的数也是补码，这一点对于如果结果是正数的花不重要，如果是负数的话，需要再 -1 后取反才能得到正确的结果。不要被误导了。

当然我前面这么说，你可能会误会以为每次在计算前都要取补码，实际上在计算机内部每个数在存储时就已经用补码表示了，所以可以直接计算，不需要每次取补码。