### **操作系統3-內存管理(請求分段存儲管理)**

#### 8.請求分段存儲管理

8.1 **請求分段的原理與硬件支持**

在段式存儲管理實現的虛擬存儲器上，以段為單位進行換入，換出。相比於請求分頁存儲系統，分段存儲因為段的大小不固定，所以置換算法更加難以實現。請求分段管理的實現需要**段表機制、缺段中斷機制和地址變換機構的支持**。

1. 段表機制

   段表結構除了段名、段長和段在內存中的起始地址外，還增加了一下幾項：

   1. 存取方式，用於標識本分段的存取屬性是執行、只讀還是可讀可寫。
   2. 訪問字段A，含義與請求分段的響應字段相同，用於記錄被訪問段的頻率。
   3. 修改位M，表示該頁進入內存後是否被修改過。
   4. 存在位P。表示該段是否已被調入內存。
   5. 增補位，表示該段在運行過程中是否動態增長。
   6. 外存起始地址。表示本段在外存的起始磁盤塊號。

2. 缺頁中斷機制

   與請求分頁系統類似。

3. 地址表換機構

   與請求分頁系統類似

8.2 **段的共享與保護**

段是按邏輯意義劃分的，可以按名存取，所以可以方便地實現內存的共享，並進行有效的內存保護。

1. 段的共享

   所謂共享，即兩個或以上的作業共用一個子程序段或數據段，該部分在內存中只有一個副本。如多個c程序都調用了Math.h庫，共用一個程序。具體的操作是在每個進程的段表中，在響應的表項加上共享段在內存的起始地址。

   當用戶進程或作業要共享內存的某一段時，只要**用戶使用相同的名字**，就可以在新的段表中填入已存在段的內存起始地址。

   為了實現共享段，可以在系統中設置一個共享段表，所以共享段都在表中佔一個表項。表中除了記錄段的一些基本信息之外，還記錄了訪問該段的進程數量count。當新增進程訪問時，就在段表中填上進程名、存取控制權限，然後count加一，標明增加一個進程訪問該共享字段。當每個進程在訪問結束後，便會將count 減一，當沒有進程共享此段時，系統便會釋放其內存。

2. 段的保護

   主要包括地址越界保護和存取方式控制保護。

   **地址越界保護**是為了保持段之間的相對獨立。但是有的段是運行動態增長的，這樣的段當段內地址大於段長時是允許的，這一點可以通過段的增補位來控制。

   **存取控制檢查**，段表的每個表項都有設置存取控制字段來設置存取權限。

   **環保護結構**。規定低標號的環具有較高的優先權，操作系統居于0環，重要軟件居於中間環，一般的居於外環。程序的訪問和調用遵循以下原則：

   1. 一個程序可以訪問駐留在相同環或較低環的數據。
   2. 一個程序可以調用駐留在相同環或高特權環的服務。