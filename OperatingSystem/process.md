#### **操作系统-进程管理1**

1. 进程的基本状态和转换

* 基本状态：

  * 就绪状态：外部条件已经满足，但因为得不到CPU资源，暂时无法运行
  * 执行状态：就绪状态得到CPU资源后进入执行状态
  * 阻塞状态：进程因为等待某件事情的发生而暂时不能执行，也就是不具备外部执行条件。

* 进程转换：

  进程在被挂起(suspend)之后进入静止状态，静止状态也分为就绪和阻塞。因此进程共有5种状态。通过Active激活原语可将静止进程转换到活动进程，同样通过suspend原语可以将活动进程变为静止进程，即为挂起。

2. Linux进程的状态

   Linux在内核中通过task_struct结构来表示，进程状态通过该结构的state成员来描述。

* TASK_RUNNING状态：该状态包括上述状态中运行和就绪状态，靠是否正在占用CPU资源进行区分，Linux中有current变量进行区分。
* TASK_INTERRUPTIBLE状态：可中断的等待状态，Linux把等待状态分为可中断的等待状态和不可中断的等待状态。可中断的意思是该进程的等待状态可以通过信号唤醒进入就绪状态。
* TASK_UNINTERRUPTIBLE状态：不可中断的等待状态。
* TASK_STOPPED状态：一般由运行状态转换而来，等待某种特殊的处理。

3. 进程组成

* 程序：表示进程需要完成的功能
* 数据集合：表示进程需要处理的数据
* PCB(Process Control Block):PCB是用来描述进程当前的状态和本身的特性的数据结构。包含了一个进程的描述信息、控制信息和资源信息。PCB最早被创建，在进程完成其功能才被释放。PCB大致有四个部分：进程标识符、处理机状态、进程调度信息和进程控制信息。
  * **进程标识符**：唯一地标识一个进程
    * 进程内部标识符：操作系统为每个进程赋予的唯一的数字表示符
    * 外部标识符：由创建者提供，由字母、数字组成。
  * **处理机状态**：由处理机的各种寄存器的内容组成。当处理机被中断时，PCB要保留寄存器中的这些信息，以便在进程重新执行时能够从断点处继续执行。寄存器包括：通用寄存器、指令计数器、程序状态字PSW和用户栈指针。
  * **进程调度信息**：与进程调度和进程对换有关的信息。包括**进程状态、进程优先级、进程调度有关的信息和事件或阻塞原因**(指进程由执行状态转变为阻塞状态所需要等待的发生的事件)。
  * **进程控制信息**：
    * 程序和数据的地址：进程的程序和所需的数据所在的地址。程序在运行时可以从PCB中获得所需的数据的地址。
    * 进程同步和通信机制
    * 资源清单：一张除了CPU资源外，包含了进程所需的全部资源以及进程已经获取到的资源的清单。进程可以根据该清单确定是否已经满足外部条件进入就绪状态。
    * 链接指针：本进程PCB所在队列的下一个进程PCB的首地址。

4. PCB的组织方式

* 线性方式：系统预先确定整个系统同时存在的最大线程数目和静态分配空间。限定了同时存在的进程的最大数目，同时在进行进程调度时需要扫描整张表，效率比较低。
* 链接方式：按照进程的不同状态将其放在不同的队列中。**在单CPU的情况下，运行状态的队列只有一个**。其他的状态的队列可以有多个，按照不同的划分。对于就绪状态的队列，**CPU调度程序总是把第一个PCB从该队列拿下投入运行队列。而新加入就绪队列的PCB按照某种调度算法进行插入**。阻塞队列有多个，对应不同的阻塞原因。正在运行的进程由于某种原因进入阻塞状态时就会进入阻塞队列。**Linux就是应用这种PCB的组织模式**。
* 索引方式：建立几张索引表，如就绪索引表、阻塞索引表，表中记录了某个PCB在PCB表中的地址。

5. 进程控制

   进程控制即系统使用一个具有特定功能的程序段来创建、撤销进程以及完成进程各状态间的转换。

* 进程的家族关系：

  进程可利用**系统调用功能**来创建新进程，创建者称为父进程，被创建者称为子进程。子进程也可创建进程，从而形成一棵进程树。

  子进程的许多功能都是从父进程继承而来，包括：**用户标识符、环境变量、打开文件、文件系统的当前目录、已经连接的共享存储区和信号处理例程入口表等**。

  还有一种进程在系统启动时被创立，在系统停止时终止，有及其重要的地位。如UNIX系统的0^#进程和1^#进程。0^#进程是系统的调度和对换进程，1^#进程是创建进程，是所有进程的祖先进程。

  Linux系统由init()函数创建系统的第一个进程init，标识符为1，其完成一些初始化任务如**打开系统控制台、安装根文件系统、启动系统的守护进程、执行系统的初始化程序等。init进程使用ect/inittab作为脚本文件创建新进程。** 

* 进程的创建与终止

  要运行程序必须要创建一个进程，导致进程创建的事件有用户登录、作业调度和为用户提供服务等。

  * 创建进程的步骤：

    * **申请空白PCB**。为新进程获得一个唯一的进程标识符，并在PCB集合中申请一块空白的PCB。
    * **为进程分配资源**。包括新进程的程序、数据及用户栈所需的内存空间。此时，**系统必须知道新进程所需的内存大小**。
    * 初始化进程控制块。
    * 将新进程的PCB插入就绪状态队列。

  * 终止进程：

    当系统发生了要求进程终止的事件，操作系统就调用终止进程的原语，终止进程。

    * 根据进程标识符从PCB队列中检索出该进程的PCB，读取其状态。
    * 若处于执行状态，则立即停止执行，停止后重新进行进程调度。
    * 检查该进程是否有子进程，若有，子进程全部终止。
    * 释放终止进程的资源，归还给父进程或系统。
    * 将该进程从PCB队列中移除。

* 进程的阻塞与唤醒。(比较简单，省略)

* Linux系统调用

  * fork()系统调用：Linux利用fork()系统调用创建一个新进程。调用格式通常为:```int pid = fork();```

    pid=0:创建子进程成功,表示从子进程返回，CPU正在运行该子进程。

    pid>0:创建子进程成功，表示从父进程返回，pid为新创建子进程的标识符。

    pid=-1：创建子进程失败

  * exec()系统调用：

    fork()系统调用创建的子进程和父进程执行的是同一段代码，但是完成的是不同的工作。Linux中fork()创建子进程后，可以由exec()系统调用执行另一个程序。

    调用格式为:

    ```int execl(path,arg0[,arg1,..],0)```

    ```char *path,*arg0,*arg1..```

    exec函数族的作用是根据文件名找到相应的可执行文件，也就是在调用进程的内部执行一个可执行文件。执行成功不会返回，失败返回-1

  * exit()系统调用：

    Linux利用exit来实现进程的自我终止。进程在调用exit()并非马上消失，而是进入了僵尸状态，它已经释放了除PCB外的几乎所有内存。

  * wait()系统调用：

    该调用将进程挂起，直到接收到终止信号。

#### 操作系统-进程管理2(进程的同步与互斥)

6. 进程的同步与互斥

* 两个或两个以上的进程不能同时使用的资源称为**临界资源**。临界资源的存在带来了进程之间的互斥访问的问题。

* **进程互斥**：逻辑上完全独立、毫无关系的两个进程因为竞争同一块资源而相互制约，称为进程互斥。

* **进程同步**：有协作关系的进程不断调整它们之间的相对速度或执行过程，以保证临界资源的合理利用和进程的顺利执行。一般借由中间媒体实现：如**信号量操作**、**加锁操作**等。同步机制应遵循的规则：

  * 空闲让进
  * 忙则等待
  * 有限等待：进程等待进入临界区的时间必须是有限的，避免进入忙等状态
  * 让权等待：进程不能进入自己的临界区时，应立即释放处理机。

* 锁机制

  * 上锁与开锁

    锁机制采用锁变量```w```表示临界区是否上锁。```w=1```表示已上锁

    高效率的上锁与开锁原语为:

    ```c
    //加锁原语
    Lock w()
    {
        while (w == 1) { //表示当前进程进入不了临界区
            保护当前进程的CPU现场;
            将当前进程放入w的等待队列，将该进程置于"等待"状态;
            转进程调度;
        }
    }
    
    //开锁原语
    Unlock() {
        if (w等待队列不空) {
            移出等待队列首元素;
            将该进程置于就绪状态，并放入就绪队列;
        }
        w = 0;
    }
    ```

    所有要访问临界区的进程必须先执行上锁原语，上锁原语顺利通过，则进程可进入临界区；在完成对临界区的访问后，则执行开锁原语，释放该临界资源。

* 信号量机制

  信号量机制中申请和释放临界资源的原语为操作为wait操作和signal操作，也被称为P操作和V操作。信号量：在信号量同步机制中用于实现进程的同步与互斥的有效数据结构。常见的有**整型信号量、记录型信号量、AND型信号量及信号量集**。

  * 整型信号量

    整型信号量s表示当前可用的该类临界资源的数量:

    s > 0:系统中空闲的该类临界资源的数量

    s = 0:系统中临界资源数量为0，且没有进程在等待

    s < 0:s的绝对值表示系统中等待的进程的数量

    ```c
    wait(s):
    	while (s <= 0) {
            该进程等待;
            s--;
        }
    
    signal(s): s++;
    ```

  * 记录型信号量

    记录型信号量数据结构为:

    ```c
    struct semaphore{
        int value;
        struct PCB *queue;
    };
    ```

    value的值表示系统可用的临界资源的数量，而queue为进程链表指针，指向等待该类资源的PCB队列。

    记录型信号量的原语操作为:

    ```c
    semaphore S;
    
    //wait操作
    wait(S) {
        S.value--;
        if (S.value >= 0) {
            本进程申请到资源，继续执行;
        }
        else{
            调用block原语，将本进程加入阻塞队列，保护CPU现场，释放处理机资源;
            转进程调度;
        }
    }
    
    //signal操作
    signal(S) {
        S.value++;
        if (S.value <= 0) {//说明PCB队列还有其它进程在等待
            在queue唤醒一个阻塞态进程;
        }
        释放本进程占用的该临界资源，继续执行;
    }
    ```

7. 进程同步问题举例

* 例7.1 同步使用打印机

  ```c
  semaphore s;
  s.value = 1;
  void main(){
      parbegin(p1,p2,p3,..,pn);
  }
  pi(){ //i = 1,2,3,...,n
      wait(s);
      打印;
      signal(s);
  }
  ```

* 例7.2 有一个缓存区，供多个进程共享，这些进程中有读进程和写进程。写一个多个进程使用同一个缓存区实现进程同步的程序。

  ```c
  semaphore empty,full;
  empty.value = 1; //empty用来表示缓存区是否是已被写入的状态
  full.value = 0; //full表示缓存区是否是已被读出的状态。
  
  reader() {
      while (true) {
          wait(full); //读之前先使full置于value为0的状态，避免其它进程也进入读取
          读缓存区;
          signal(empty); //读完后置empty的value为0，表示缓存区的数据已经读完了，可以继续写入了。
      }
  }
  
  writer() {
      while (true) {
          wait(empty);
          写缓存区;
          signal(full);
      }
  }
  
  //通过设置两个信号量实现了writer和reader的交替执行
  void main() {
      prebegin(writer,reader);
  }
  ```

* 例7.3 **生产者-消费者问题**：生产者进程生产产品，放入容量为n的缓存区供消费者拿走。消费者不能上空缓存区拿东西，生产者不能上满的缓存区放东西。这个与上个文件读写的例子有些类似。

  ```c
  /*
  用一个数组表示具有n个缓存区的缓存池。设有输入指针in指向一个可存放产品的缓存区，输出指针out指向可取得产品的缓存区。由于数组可以循环放置，所以当输入或输出加一时，可表示为: in = (in + 1) % n, out = (out + 1) % n。当(in + 1) % n = out时，表示缓存池已满，当in = out时，表示缓存池已空。整型counter表示缓存池中满缓存区的数量。
  还有以下变量:
  mutex:互斥使用缓存池信号量，初值mutex = 1
  empty:空缓存区的信号量
  full:满缓存区的信号量
  */
  semaphore mutex, empty, full;
  mutex.value = 1;
  empty.value = n;
  full.value = 0;
  
  product buffer[n];
  int in = 0,out = 0;
  
  void main() {
      prebegin(producer, consumer);
  }
  void producer() {
      while (true) {
          生产一件产品;
          wait(empty);
          wait(mutex);
          将产品放入缓存区;
          counter++;
        	in = (in + 1) % n;
          signal(mutex);
          signal(full);
      }
  }
  void consumer() {
      while (true) {
          wait(full);
          wait(mutex);
          拿走一件产品;
          counter--;
          out = (out + 1) % n;
          signal(mutex);
          signal(empty);
      }
  }
  //注意：在这两个进程中两个wait()信号量的顺序不能改变，必须先要申请到full资源或empty资源才能继续申请mutex的资源，否则可能会造成申请到mutex的资源但却申请不到full或empty的资源的情况，然后进程就会进入等待状态，使得signal(mutex)不能执行，造成缓存池的锁死。
  ```

  这个问题比较有代表性，**一般把系统中使用同一类资源的进程称为该资源的消费者，释放该类资源的进程称为生产者。**

* 例7.4 **读者-写者问题**：文件F可以被多个进程共享，向F中写的称为写进程，读取F的称为读进程。用wait和signal解决进程间的同步问题。

  ```c
  //F可以同时被多个进程读，但不能被多个进程同时写，否则会造成数据的混乱.或者说一个写进程会对其他所有进程造成排斥。
  semaphore wmutex,rmutex;
  wmutex.value = 1;
  rmutex.value = 1; 
  int readcount = 0; //正在进行读操作的进程数量，因为readcount是一个会被多个读进程访问的资源，所以上文设置了rmutex来控制访问。
  void main() {
      prebegin(writer,reader);
  }
  void writer() {
      while (true) {
          wait(wmutex);
          写操作;
          signal(wmutex);
      }
  }
  void reader() {
      while (true) {
          wait(rmutex); //要想访问readcount必须先申请资源。
          if (readcount == 0) { //如果没有同类型进程在访问该资源,则需要进行申请
              wait(wmutex);
          }
          readcount++;
          signal(rmutex);
          读操作;
          wait(rmutex);
          readcount--;
          if (readcount == 0) signal(wmutex);
          signal(rmutex);
      }
  }
  ```

  这个问题也是一类问题的典型代表，不同于生产者-消费者问题，这种模式允许任意多个有特定行为的进程进入，但不允许其他类型进入。即同类型进程之间不存在互斥现象。解决这一问题的**关键就是当有至少一个同类型的进程正在访问该资源时，本进程便可以不必进行资源申请，直接访问该资源。**

* 例7.5 **哲学家进餐问题**：五个哲学家围着一张餐桌吃饭，桌上有5支筷子，在每个人之间放一支。哲学家只有拿到了左右两支筷子才能进餐，没有拿到则只有等到别人吃完才能拿到。每个哲学家在吃到东西之前不会放下手里的筷子。试描述哲学家吃饭的过程。

  假设每一位哲学家拿筷子的方法都是先拿左边的，再拿右边的。则第i位哲学家的拿筷子过程可描述为:

  ```c
  //每一根筷子都是临界资源，为此设立一个筷子信号量数组
  semaphore chopstick[5];
  //每根筷子的初始值为1,筷子i相邻筷子的索引为(n+i-1)%n 和(i+1)%n。设哲学家i位于筷子i的右边
  void main() {
      prebegin(p1(),p2(),p3(),p4(),p5());
  }
  void pi() {	//p表示哲学家的吃饭过程
  	while (true) {
          wait(chopstick[i]);
          wait(chopstick[(i + 1) % n]);
          吃饭;
          signal(chopstick[(i + 1) % n]);
          signal(chopstick[i]);
      }
  }
  ```

  但是这种做法会造成一个问题，即所有哲学家同时拿起了左边的筷子，导致没有哲学家能拿到右手的筷子。造成了**死锁**。

  解决死锁的方法有多种，如：

  1).仅当哲学家的左右手的筷子均可用时才允许拿起筷子

  2).最多允许n - 1个哲学家同时去拿左边的筷子，保证总有一个哲学家能够拿到一双筷子。#### 操作系统-进程管理3(进程通信)

8. 进程通信

   进程间的通信分为控制信息的传送和大量信息的传送两种，控制信息的传送称为**低级通信**，大批量数据的传送称为**高级通信**。

   高级通信分为**共享存储系统、消息传递系统和管道通信系统**。


* 共享存储系器系统

  1. 共享存储器系统类型：在共享存储系统中，相互通信的进程共享某些**数据结构**或**共享存储区**，进程之间能通过这些空间进行通信。

  * 共享数据结构的通信：在这种方式中，要使各进程间共享某些数据结构以实现进程间的信息交换。如生产者-消费者问题中，生产进程和消费进程共享了empty和full的信号量，使得彼此知道能否放置或拿走产品。这种方式只适用于传递少量的数据。
  * 共享存储区的通信：为了实现高级通信，在存储区划出一块共享存储区，各进程可通过对共享存储区的读或写来实现通信。进程在通信前，先向系统申请获得共享存储区的一块分区，并指定该分区的一个关键字；若系统已经给其他进程分配了这样的分区(如本进程是读进程，但是已经有同类的读进程在读这块数据)，则将该分区的描述符返回给申请者，由申请者去连接共享存储区。

  2. Linux共享存储区通信的实现

     1).共享存储区的建立：当进程要利用共享存储区与另一个进程进行通信时，必须先让系统调用shmget()建立一块共享存储区。

     2).共享存储区的操纵：系统可以调用shmctl()对共享存储区的状态信息进行查询，如长度、所连接的进程数、创建者标识符等；也可设置或修改其属性，如共享存储区的许可权、当前连接的进程计数等；还可以对共享存储区进程加锁和解锁，以及修改共享存储区的标识符等。

     3).共享存储区的附接与断开：当进程已经建立了共享存储区或已获得了去描述符后，还要利用系统调用shmat()将该共享存储区附接到用户给定的某个进程的虚地址shmaddr上，并指定该存储区的访问属性。此后，该共享存储区便成为该进程虚地址空间的一部分。当进程不再需要该共享存储区时，就利用shmdt()将该区与本进程断开。

* 消息传递系统

  消息传递系统中，进程间的数据交换是以**格式化的消息**(Message)为单位的，程序员可直接利用系统提供的一组通信命令直接进行通信，操作系统隐藏了实现通信的细节。因实现方式的不同分为直接通信和间接通信。

  1. 直接通信方式

     这种通信固定在一组进程间进行。如A只发生给B，B只接收A的信息。系统提供了两条原语send和receive用来发送和接收消息。

     ```
     send(B,message);
     receive(A,message);
     ```

  2. 间接通信方式

     间接通信又称为信箱通信，信箱是一种数据结构，分为信箱头和信箱体，信箱头包含了信箱体的结构信息，例如多进程共享信箱体时的同步互斥信息。信箱体由多个格子组成，它实际上就是一个有界缓冲池，它的同步-互斥方式与生产者-消费者模式类似。信箱模式一般是进程间的双向通信。信箱的创建者即拥有者。信箱分为三类：

     (1)**私有信箱**：又用户进程创建，并且作为进程的一部分。用户有权从信箱读取信息，其他进程只能向该信箱发送消息。进程结束后，信箱也随之撤销。

     (2)**公有信箱**：由操作系统创建，所有受到核准的进程均可向信箱中发送和读取信息。信箱在系统运行期间一直存在，通常采用双向通信链路的信箱实现。

     (3)**共享信箱**：由某进程创建，创建时必须指出可以共享信箱的进程的用户名或进程标识符。信箱的创建者和共享者都有权从信箱中取信息。

  3. **消息缓冲队列通信机制**

     消息缓冲队列是为了接收进程同时接收多个发送进程发送的消息而设立的。

     (1)消息缓冲队列通信机制所用的数据结构主要是**消息缓冲区**，描述如下：

     ```c
     struct message {
         char sender[];   //发送进程标识符id
         int size;		//消息长度
         char text[];	//消息正文
         queue *next;	//消息队列的指针
     }
     ```

     在设置消息缓冲队列时，还应添加用于对消息队列进行操作和实现同步的信号量到进程的PCB中：

     ```c
     struct PCB {
     	queue *mq;	//消息队列首指针
         semaphore mutex;	//互斥信号量
         semaphore sm;	//消息队列资源信号量
     }
     ```

     在一个发送进程发送信息时，并形成了一个Message，并发送给指定的接收进程。接收进程将所有的消息缓冲区链接成一个队列，队首由PCB中的队首指针mq指出。

     (2)**发送原语**。发送进程在发送消息之前，会先在自己的内存设置一个发送区，把待发送的消息正文，发送进程标识符，消息长度等信息填入其中，再调用发送原语发送消息。发送原语会首先根据发送取设置的消息长度来申请一个缓冲区i，再把发送区的消息复制到缓冲区中。为了能够将缓冲区的消息挂在接收进程的消息队列中，应先获得接收进程的**内部标识符j**，再将缓冲区i挂在j.mq上。因为该队列属于临界资源，所以在执行挂接操作时，需要执行wait和signal操作。发送原语描述如下:

     ```c
     void send(receiver,m) { //m表示消息缓冲区，即message
         getbuf(m.size,i); //申请缓冲区,标为i
         i.sender = m.sender;
         i.size = m.size;
         i.text = m.text;
         i.next = 0;
         getid(PCB of receiver,j); //获得接收者进程id
         //消息队列是临界资源，需要进行申请
         wait(j.mutex);
         insert(j.mq,i); //将缓冲区i插入j.mq中
         signal(j.mutex);
         signal(j.sm);
     }
     ```

     (3)接收原语。接收进程调用接收原语，从消息队列中选取第一个消息缓冲区，并将消息复制到指定的消息接收区内。描述如下：

     ```c
     void receive(m) {
     	j = internal name; //获得本进程的内部标识符id
     	wait(j.sm);
     	wait(j.mutex); //这两个wait的顺序同样不能更换
     	remove(j.mq,i);
     	signal(j.mutex);
     	//将i中的数据复制到m中
     	m.sender = i.sender;
     	m.size = i.size;
     	m.text = i.text;
     	releasebuf(i); //释放i
     }
     ```

     (4)Linux系统关于消息传递的相关系统调用。使用msgget(key,flag)系统调用申请消息，获得一个消息的描述符，该描述符指定一个消息队列以便用于其他系统调用。使用msgsnd(id,msgp,size,flag)系统调用发送一条消息。使用msgrcv(id,msgp,size,type,flag)接收一条消息。使用msgctl(id,cmd,buf)查询一条消息描述符状态，设置状态及删除一个消息描述符。

* 管道通信系统

  管道是指用于连接一个读进程和一个写进程，以实现它们之间的通信的一个**共享文件**，又称为**pipe文件**。向管道提供输入的发送进程(写进程)，以**字符流**的形式将大量的数据通过管道传输给另一端的接收进程(读进程)。这种方式首创于UNIX系统，在Linux系统及其他系统中得到了广泛应用。管道机制必须提供以下三方面的协调能力：

  (1)互斥：当一个进程在对pipe执行读/写操作时，其它进程必须等待。

  (2)同步：当写进程把一定数量的数据输入到pipe后便去睡眠等待，直到读进程将数据读出才将它唤醒。当读进程读到一个空的pipe时，也进入睡眠等待，直到写进程写入新的数据才将它唤醒。这样能够确保数据的同步，不会发生错乱。

  (3)读进程和写进程互相确定对方是否存在，只要两个都存在才能进行数据的传输。

9. 信号通信机制

* 信号的概念

  每个信号对应一个正整数常量，称为signal number，即信号编号。它定义在系统头文件<signal.h>中，代表同一用户的各进程之间传送事先约定的信息类型，用于统治某进程发生了异常事件。每个进程运行时都会根据信号机制检查是否有信号到达，若有，则会中断当前程序的运行，转到与该信号对应的处理程序，以完成对该事件的处理，处理完后再返回先前的断点继续执行。进程对于信号可以屏蔽，所有的信号都是平等的，且进程对于信号的响应通常有比较长的延迟。#### 操作系统-进程管理(线程)

10. 线程

* 线程的基本概念

  线程是比进程更小的、能够独立运行的基本单位，线程比进程能更好地提高程序的并行执行速度，充分利用多处理机的优越性。引用线程主要是为了提高系统的处理效率，减少处理机的空转时间和进行调度时因保护CPU现场浪费的时间。

  线程是**进程中执行运算的最小单位**，即执行处理机调度的基本单位。在引入线程的操作系统中，可以在一个进程内部进行线程的切换。

  进程是资源分配的基本单位，同一进程的所有线程共享该进程的所有资源。线程是分配处理机的基本单位，真正在处理机上运行的是线程。

  Linux系统中没有区分进程和线程，它们都使用相同的描述方法，使用相同的调度和管理策略。

* 线程的状态与转换操作

  线程只有三种基本状态：**执行、阻塞和就绪**。针对线程的三种状态，存在五种操作来转换线程的状态。

  * 派生(Spawn)

    线程在进程中派生出来，也可再派生线程。用户可以通过相关的系统调用来派生自己的线程。Linux系统中，库函数clonc()和create_thread()分别用来派生不同执行模式的线程。

    一个新派生出的线程具有相应的数据结构指针和变量，这些指针和变量作为**寄存器上下文**放在本线程的寄存器和堆栈中。新派生出来的线程被放入就绪队列。

  * 调度(Schedule)

    选择一条就绪线程进入执行状态。

  * 阻塞(Block)

    如果一个线程在执行过程中需要等待某个事件发生，则被阻塞。阻塞时，寄存器上下文，程序计数器，及堆栈指针都会得到保证。

  * 激活(Unblock)

    如果阻塞线程所等待的事件发生，则该线程被激活进入就绪队列。

  * 结束(Finish)

    一个线程执行结束，它的寄存器上下文以及堆栈内容等将被释放。

* 引入线程的好处

  * 易于调度。由于线程只作为独立调度的基本单位，同一进程的多个线程共享进程的资源，所以进程易于切换。
  * 提高了系统的效率。通过线程可以有效地实现并发性，进程可创建多个线程执行同一个程序的不同部分。
  * 创建一个线程比创建一个进程的开销少，创建速度快。

* 多线程的实现

  线程分为用户级线程和内核级线程(也称核心级线程)。

  * **用户级线程ULT(User Level Thread)**。是由用户应用程序建立的，并由用户应用程序进行调度和管理。操作系统内核并不知道这些线程的存在，只对进程进行管理。因此这种线程与内核无关。

    ULT的优点如下：

    (1)应用程序中线程开关的时空开销远小于内核级线程的开销。

    (2)线程的调度算法与操作系统的调度算法无关。

    (3)因为与操作系统内核无关，所以适用于任何操作系统。

    缺点为:

    (1)在一个典型的操作系统中，有许多的系统请求正在被阻塞着，因此当一个线程执行一个系统请求时，不仅本线程被阻塞，该进程所有线程都被阻塞。

    (2)在该方法的系统中，因为**每个进程每次只能由一个线程在CPU运行**，因此无法利用多处理器的优点。

  * **内核级线程KLT(Kernel Level Thread)**。内核级线程中所有线程的创建、管理与调度都由操作系统内核完成。一个应用程序可以按多线程的方式编写程序，当它提交给一个多线程的操作系统执行时，内核会为它创建一个进程和一个线程，线程可以创建新的线程。操作系统内核会为应用程序提供相应的系统调用和应用程序接口，以便用户程序可以创建、执行和撤销线程。Windows NT便是此类。
  
    内核级线程优点：
  
    (1) 内核可调度一个进程中的多个线程，使其在多个处理机上并行运行，从而提高系统的效率。
  
    (2) 一个线程被阻塞时，其它线程仍可运行。
  
    (3) **内核本身可以以线程方式运行**。
  
    缺点:
  
    由于线程调度程序运行在内核态，而用户程序运行在内核态，因此同一进程中的线程切换要经过从用户态到内核态，再从内核态到用户态的两次模式的切换。于是催生了**用户级线程与内核级线程相结合的模式**。
  
* Linux系统的线程

  Linux的内核级线程也称为系统级线程。Linux可以同时支持内核级线程和用户级线程。大多数操作系统对于线程单独定义数据结构，采用单独的线程管理方式。而Linux将线程定义为**“执行上下文”**，它实际上只是进程的另外一个执行上下文而已，和进程享有相同的表示、管理和调度方式。执行上下文的定义可参考下面这个

  > 用户空间的应用程序，通过系统调用，进入内核空间。这个时候用户空间的进程要传递 很多变量、参数的值给内核，内核态运行的时候也要保存用户进程的一些寄存器值、变量等。**所谓的“进程上下文”，**可以看作是用户进程传递给内核的这些参数以及内核要保存的那一整套的变量和寄存器值和当时的环境等。

  那么什么是**内核空间**和**用户空间**呢？它们的一个主要的区别就是两者所能访问到的资源不同。

  > **内核空间具有最高的权限，可以访问到所有资源。而用户空间只能访问受限权限，不能直接访问内存等硬件设备，必须通过系统调入到内核中才能访问这些特权资源。**进程既可以在用户空间运行，又可以在内核空间中运行。进程在用户空间运行时，被称为进程的用户态，而陷入内核空间的时候，被称为进程的内核态。

  要想从用户态转到内核态，需要通过**系统调用**来完成。

  >比如，当我们查看文件内容时，就需要多次系统调用来完成：首先调用 open() 打开文件，然后调用 read() 读取文件内容，并调用 write() 将内容写到标准输出，最后再调用 close() 关闭文件。
  >
  >在这个过程中就发生了 CPU 上下文切换，整个过程是这样的：
  >1、保存 CPU 寄存器里原来用户态的指令位
  >2、为了执行内核态代码，CPU 寄存器需要更新为内核态指令的新位置。
  >3、跳转到内核态运行内核任务。
  >4、当系统调用结束后，CPU 寄存器需要恢复原来保存的用户态，然后再切换到用户空间，继续运行进程。
  >
  >所以，**一次系统调用的过程，其实是发生了两次 CPU 上下文切换**。（用户态-内核态-用户态）

  ---

  本文引用部分的文字来自知乎文章:[一文让你明白CPU上下文切换][https://zhuanlan.zhihu.com/p/52845869]
#### 操作系统-进程管理(习题)

本文将回答一下课后的习题

1. 程序并发执行为什么会失去封闭性和再现性

   答：在并行执行程序时，系统资源由多个程序所共享，则这些资源必然由这些程序来改变。程序执行时，必然会受到其他程序的影响。正是因为如此，不能以程序作为作为描述其执行过程的基本单位，催生了后来进程及进程上下文的出现。

2. 什么叫进程的并发性？

   答：进程的并发性是指操作系统中可以同时运行多个进程，CPU虽然一次只能执行一个进程，但可以在多个进程之间进行快速的切换，宏观时间上来看就是多个进程在并行执行。

3. 试说明PCB的作用，为什么说PCB是进程存在的唯一标志？

   答：进程是由PCB、程序和数据集合构成的，PCB的存在体现了进程的动态性。

   进程包含了进程标识符、处理机状态(由处理机的各种寄存器的内容组成)、进程调度信息和进程控制信息。

   PCB的存在是进程可以并发执行的关键，进程从被唤醒到被挂起和被切换都需要PCB记录信息。

   在进程被创建时，PCB最早被创建，进程被撤销时，PCB最晚被释放。所以可以说PCB是进程存在的标志。

4. 进程的创建包含了哪些过程

   (1) 申请空白PCB。为新进程申请一个唯一的进程标识符，在PCB集合中申请一块空白PCB。

   (2) 为新进程分配资源。主要是新进程的程序、数据及用户栈所需的内存空间。

   (3) 初始化PCB。主要是将各种信息填入PCB中，如：进程标识符、父进程标识符、处理机状态，将程序计数器指向程序的入口地址，栈指针指向栈顶，处理机控制信息，新进程设置为就绪状态，新进程的优先级。

   (4) 将新进程的PCB插入就绪队列。

5. 进程的高级通信方式有哪几种？

   (1) 共享存储器系统：相互通信的进程共享某些数据结构或存储区，进程之间通过这些空间通信。

   (2) 消息传递系统：分为直接通信方式和间接通信方式。直接通信即两个进程之间直接发送message。间接通信即发送进程将message发送到信箱。信箱又分为私有信箱、公有信箱和共享信箱。发送进程发送消息时，先在自己的内存中申请一发送区，将要发送的正文和其他一些信息填入其中。发送原语则负责根据消息长度设置一个缓冲区，即“信箱”。将要发送的信息复制到其中。接收进程再从缓冲区里复制信息。

6. Linux系统的进程有几种状态？

   (1) TASK-RUNNING状态。包含了运行状态和就绪状态，具体是哪一种要靠是否占用了CPU资源来区分。

   (2) TASK-INTERRUPTIBLE状态。进程正在等待某些事件。可中断状态的进程可以被信号唤醒进入就绪状态等待被调入。

   (3) TASK_UNINTERRUPTIBLE状态。因为某些硬件资源没满足而中断的进程。

   (4) TASK_ZOMBIE状态。僵死状态。由于某些原因进程被终止，进程所有的资源都已经被释放，但是PCB信息还被保留。这种状态就称为僵死状态。

   (5) TASK_STOPPED状态。暂停状态。一般由运行状态转换而来，等待某种特殊处理。

7. 在读者-写者问题中，修改问题的同步算法，当有写进程到达时，后续读进程必须等待，而不管是否有读进程在读文件。试写出相应的程序段。

   ```c
   semaphore mutex; //mutex是对文件进行读\写操作的信号量。
   
   int readcount = 0, arrive = 0;//arrive是表示写进程是否到达的变量，0表示未到达，1表示到达。
   
   void writer() {	
   	arrive = 1;
   	wait(mutex);
   	写操作...
   	signal(mutex);
   	arrive = 0;
   }
   
   void reader() {
   	if (arrive == 1) return; 
   	if (readcount == 0) {
   		wait(mutex);
   	}
   	readcount++;
   	读操作...
   	readcount--;
   	signal(mutex);
   }
   ```

   

