### 1.传输层和协议
* 传输层为运行在不同主机上的进程提供了一种逻辑通信机制，而网络层为主机之间提供了逻辑通信机制
* 端系统运行传输层协议
    * 发送方：将应用递交的消息分成一个或多个的Segment，并向下传递给网络层
    * 接收方：将接收到的segment组装成消息，并向上交给应用层

### 2.多路复用和多路分用
* 多路分用：传输层依据头部信息将受到segment交给正确socket，即交给不同的进程。
    * 无连接多路分用
        * 利用端口号创建socket
        * UDP的socket用二元组标识（目的IP地址+目的端口号）
        * 主机收到UDP段之后，检查段中的端口号，将UDP段导向绑定在该端口号的socket。
        * 来自不同源IP地址或源端口号的IP数据报被导向同一个socket
    * 面向连接的多路分用
        * TCP的socket用四元组标识
        * 接收端将四个值都导向socket
        * 服务器可能同时支持多个TCP socket
        * 同一个进程可能会有不同的线程进行多个socket连接
* 多路复用：传输层从多个socket接收信息为每个数据块封装上头部信息，生成segment，交给网络层。

### 3.UDP协议（User Datagram Protocol）
* 基于Internet IP协议
    * 复用/分用
    * 简单的错误校验
* 常用于流媒体应用
    * 容忍丢失
    * 速率敏感
    * 用于DNS,SNMP
* UDP校验和（checksum）
    * 发送方
        * 将段的内容视为16bit整数
        * 校验和计算：计算所有整数的和，进位加在和的后面，将得到的值按位取反，得到校验和
    * 接收方
        * 计算所受到段的校验和
        * 将其与校验和字段进行对比，不相等则出现错误。

### 4.可靠数据传输概述

* 4.1 可靠数据传输协议：接口

  ![rdtInterface](C:\CSNotes\ComputerNetwork\ScreenShots\rdt.png)

  上图中，可靠数据的传输为单向，不可靠的传输为双向。

* 4.2 利用状态机(Finite State Machine,FSM)来刻画传输协议
* 4.3 可靠数据传输1.0：可靠信道上的可靠数据传输
  * 底层信道完全可靠
  * 发送方和接收方的FSM独立
  * 发送方：
    * 从上层接收数据
    * 将数据打包
    * 通过底层信道传输
  * 接收方：
    * 从底层接收数据
    * 解包，提取数据
    * 传输给上层
* 4.4 可靠数据传输2.0：产生位错误的信道
	* 底层信道可能翻转分组中的位
	* 如何从错误中恢复
		* 确认机制(Acknowledgements,ACK)：接收方显式地告知发送方已正确接收
		* NAK:接收方显式地告诉发送方分组有错误。
		* 接收方知道后，重传分组
	* 基于这种重传机制的rdt协议成为ARQ(Automatic Repeat reQuest)
	* FSM的改变
		* 发送方需要多发生一个校验和checksum
		* 发送后等待接收方是否接收方收到正确信息的消息，只有收到接收方接收到正确消息的消息后才继续发送下一个分组
		* 接收方则需要增加校验环节和发送ACK环节
* 4.5 可靠数据传输2.1：
	* rdt2.0缺陷：ADK/NAK的错误无法检验，可能产生重传或者漏传。
	* 如果ACK/NAK坏掉，发送方进行重传。但不能进行简单的重传，需要在分组时加上序列号，使得接收方判断所收到的消息是否重复。
* 4.6 可靠数据传输2.2(无NAK消息协议)：
	
	* 在ACK中告知发送方最后一个正确接收的分组，在ACK消息中显式地加入确认分组的序列号。

### 5. 滑动窗口协议

* 流水线协议

  * 允许发送方在受到ACK之前连续发生多个分组

* 滑动窗口协议

  * 窗口：允许使用的序列号范围，尺寸为N，表示最多有N个等待确认的消息。随着协议的运行，窗口在序列号空间内向前滑动
  * 协议:GBN,SR

* GBN协议(G0-Back-N)

  * 分组头部有k-bit序列号

  * 窗口尺寸为N，最多允许N个分组为确认

  * ACK(N)：确认到序列号n的分组均已被确认接收，可能收到重复ACK

  * 为空中的分组设置Timer

  * Timeout事件：重传序列号大于等于Timeout后还未收到ACK的分组的序列号的所有分组，如序列号为2的分组未被成功接收，则2之后成功到达接收方的分组不会被接收。直到超时后，发送方重传2及以后的所有分组

  * ACK机制：发送拥有最高序列号的、已被正确接收的分组的ACK

  * 乱序到达的分组

    * 直接丢弃
    * 重新确认序列号最大的、按序到达的分组

  * GBN示例：

    ![GBN示例](C:\CSNotes\ComputerNetwork\ScreenShots\GBNSample.png)

* SR协议(Selective Repeat)

  * 接收方对每个分组单独进行确认。设置缓存机制，缓存乱序到达的分组。

  * 发送方只重传那些没收到ACK的分组，要为每个分组设置timer

  * 发送方窗口没变

  * 接收方窗口

    * 可以接收N组到达的分组
    * 若收到的序列号在窗口范围之外，则忽略

  * SR示例：

    ![SRSample](C:\CSNotes\ComputerNetwork\ScreenShots\SRSample.png)
  
  * SR协议困境：
    * 1. ACK在返回过程中丢失，比如序列号为1的ACK丢失。发送方重传ACK1的的分组，但是接收方的窗户已经移动到了下一组中，下一组也有同样的序列号的等待接受。导致接收错误。
    * 要求：N_R  + N_S <= 2^k. (k为序列号的位数)

### 6. 面向连接传输协议-TCP

* TCP概述：
  * 点对点
  * 可靠的字节流
  * 流水线机制
  * 同一连线中传输双向数据流
  * 发送方/接收方缓存
  * 面向连接
    * 发送数据前必须建立连接
    * 连接状态只在两段维护
  * 流量和拥塞控制
* ![TCP](C:\CSNotes\ComputerNetwork\ScreenShots\TCPSample.png)

* TCP可靠数据传输概述

  * RTT(Round Trip Time)

    * 如何设置定时器的时间是个问题，TCP的RTT并不是一成不变的，会根据网络自动改变。

    * RTT的测量：从段发出去到受到ACK的时间。测量多个取平均值。

    * $$
      EstimatedRTT = (1 - \alpha) * EstimatedRTT + \alpha * SampleRTT
      (Tipacally , \alpha = 0.125)
      $$

    * 测量RTT的变化值：
      $$
      DevRTT = (1 - \beta)*DevRTT+\beta*|SampleRTT - EstimatedRTT|(Typically,\beta=0.25)
      $$
      