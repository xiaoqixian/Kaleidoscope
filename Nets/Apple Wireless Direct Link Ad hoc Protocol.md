# Apple Wireless Direct Link Ad hoc Protocol

[toc]

### 1. 介绍

​	Apple Wireless Direct Link (AWDL) 是苹果的一项专利协议，其部署在超过12亿的组成苹果用户生态的终端设备之上，使用其的应用包括AirDrop和AirPlay等。

​	AWDL协议有以下几点值得注意：

1. AWDL基于IEEE 802.11 协议，可能存在潜在的性能和共存问题，尤其是在一般环境下，AWDL使用多条信道并且使用跳频技术，可能与现有的Wi-Fi部署存在干扰问题。
2. 在现有版本的macOS中，Wi-Fi驱动是最大的二进制内核扩展。鉴于最近发布的Wi-Fi芯片固件[7,8]中的漏洞可能会导致整个系统对[9]的破坏，我们强烈建议对该协议及其实现进行安全审计，因为非标准化协议中的漏洞更有可能发生。
3. 对该协议重新实现并开源将允许与其它操作系统互操作，最终实现高吞吐量的跨平台直接通信。

​	在本文中，我们通过二进制和运行时分析的方式对AWDL进行了一个详细的分析，并给出了其帧结构和运行方式。简单来说，AWDL是一种基于IEEE 802.11 标准并利用了允许自定义协议实现的供应商扩展来实现的协议。每个AWDL节点会定期发送action frames，其包含了一系列空闲窗口，表明其随时可与其它AWDL节点进行通信。之后一个主节点被选举出来来同步这些窗口序列。在这些空闲窗口中，节点之间可以通过一种专用的数据帧格式来彼此通信。在空闲窗口之外，节点可以将其Wi-Fi无线电调节到另一个信道来与AP点进行通信，或者直接关闭来节省电量。本文所做的工作如下：

- 提供了对于macOS操作系统和其Wi-Fi驱动架构和debugging设施的剖析
- 4到6节提供了AWDL的帧结构和运行方式
- 对AWDL进行了实验性分析来评估选举行为，同步准确性，吞吐量和跳频策略。
- 讨论了协议的复杂度，能量利用效率，并进行了初步的安全性评估，在那一步发现了macOS内核扩展中的权限安全性问题。

### 2. 背景

​	**IEEE 802.11 IBSS**.  IBSS(Independent Basic Service Set，独立基本服务集)模式更为熟知的名字是"ad hoc"模式，该模式创建一个并无特殊控制角色的分布式无线网络。IBSS 可通过在特定信道发送一个带有SSID和BSSID的信标帧(beacon frame)来创建。其它节点也可通过发送带有相同信息的信标帧来加入网络。

​	**Wi-Fi Peer to Peer**.  点对点Wi-Fi，也称为直连Wi-Fi，可以允许在无基站的情况下连接多台设备。在运行过程中，一个节点承担群组所有者(Group Owner，GO)的角色，这与基础架构模式(或BSS)非常相似。GO的角色无法转移到其它设备，如果GO离开了网络，则必须创建一个新的网络。点对点Wi-Fi网络是通过监听单个信道并发送探针到其它所有信道来建立的。这在实际中会给连接过程带来延迟，经过实验发现建立连接的过程会消耗4到10秒[11]。因此发现设备的过程会迅速消耗设备电量。

​	**TDLS**.  隧道直连建立(Tunneled Direct Link Setup, TDLS)是一项IEEE 802.11 标准的扩展，其允许两个处于同一BSS的节点进行直连。在没有TDLS的网络中，所有的节点流量都要通过AP进行，即使两个节点离得很近。TDLS要求两个节点都连接到同一个AP，因为控制帧需要通过AP进行传输，因此无法运用于真实的ad hoc 场景中。

​	**Neighbor Awareness Networking**.  邻节点感知网络(NAN)[35]，也被称为Wi-Fi感知，扩展了IEEE 802.11的接近服务发现。NAN被设计为高能效的，允许在电池供电的设备[12]上连续运行。NAN在Android 8[17]中被支持，但是我们没有找到任何与兼容硬件的设备。NAN依赖于从一个被选举的主节点发送的信标帧。它们同步一个区域内所有设备的时间。在一个短的发现窗口主设置，设备可以打开他们的无线电，交换服务和连接信息(例如，Wi-Fi P2P参数)，并再次关闭他们的收音机。事实上，我们发现AWDL使用了与NAN类似的概念，但实际实现与NAN有很大的不同。此外，NAN没有一个用于传输用户数据的数据路径。

​	**Bluetooth**.  蓝牙是一个有着不同物理和MAC层的独立标准。蓝牙和Wi-Fi一样工作在2.4GHz频域，并且经常和Wi-Fi集成到一个芯片上以共享天线。低能耗蓝牙(Bluetooth Low Energy, BLE)是与经典蓝牙协议不兼容的协议，其为低能源消耗而优化，因此提供的带宽非常有限。可用的BLE4.2 最大数据传输速率为 394 kbit/s[14]。其通常应用于小型电池驱动设备，如智能手表。BLE不是为大数据传输而设计的，但是可以应用于引导像AWDL这样的高带宽链路。

### 3. Methodology

#### 3.1 二进制分析

​	我们分析了大量的与AWDL相关的二进制文件才最终找到了与协议实现相关的部分。我们首先描述了节点选举的过程，然后讨论了实现了大部分AWDL协议的两部分Wi-Fi驱动程序。我们主要分析macOS，并假设其架构在原则上与iOS类似。我们使用反编译器来分析目标二进制文件。

​	**Binaries Selection**.  我们首先根据“802.11”、“Multicast DNS”、“sharing”等名字爬取系统的二进制文件。然后根据它们的依赖找到了更多相关的文件。下图即为找到的部分依赖和彼此的交互方式。

![image-20220620160238757](/Users/lunar/Library/Application Support/typora-user-images/image-20220620160238757.png)

虽然有一些面向用户的二进制文件，比如`sharingd`守护进程，但最相关的二进制文件都位于内核中，特别是通用的Wi- Fi驱动程序 `IO802111family` 和设备特定的变体`AirportBrcm4360`和`AirportBrcmNIC`。它们中的每一个都包含数百个与AWDL相关的函数，这表明协议栈的大部分在这里实现。我们发现`IO802111family`负责AWDL框架的大部分解析和创建，以及维护AWDL状态机。特定于设备的驱动程序处理时间关键的功能，如同步。由于这两个驱动程序部分都是macOS中最大的内核扩展，理解内部驱动程序结构是理解反编译代码的关键。

​	**Finding Interesting Code Segments**.  考虑到macOS的Wi-Fi驱动的大小，我们需要可以迅速找到实现AWDL某部分协议的函数。幸运的是，苹果并未将符号名从二进制文件中剥离出去，因此在符号表中搜索“AWDL”也可以命中一些目标。有一些符号在名字中还包含"parse" 和 "TLV"（例如`parseAwdlSyncTreeTLV`），这帮助我们理解了一些 Tye-Length-Value(TLV) 值的计算。而且，debug的日志输出也对某个函数的代码段的作用有提示作用。

​	**Leaked Broadcom Driver Source Code**.  我们使用一份过时的博通Wi-Fi驱动，其代码曾发生泄漏，可以作为另一个信息来源。我们在源代码中找到了几个AWDL的引用，但没有一个核心功能。我们怀疑Broadcom使用模块化固件概念，并使用一个中央存储库来实现广泛的功能。像AWDL这样的特殊功能被选择性地提供给他们的客户，比如苹果。比AWDL引用更重要的是源代码中的一些C结构。其中包括同步参数TLV和信道序列TLV等关键结构(详见第5节)。泄露的代码还包含了wl实用程序的源代码，该实用程序为驱动程序提供了调试功能，在第3.2节中有进一步讨论。

​	**Dissecting Structures**.  为了理解驱动的功能，我们需要重构底层的数据结构。泄漏的源代码表明大部分的AWDL相关的函数都使用 `awdl_info` 结构体作为第一个参数。`wlc_dump_awdl`函数可以以可读的形式打印数据，因此是一个适于重构结构体的目标，如下图所示：

```c
bcm_bprintf(a2, "AWDL master home channel = %d\n", awdl_info->master_home_channel);
```

我们的二进制分析结果是一个完整的对于AWDL 的 Wireshark剖析，我们也使用它来动态分析协议和评估我们的实验。

#### 3.2 运行时分析

​	单靠二进制分析很难完全理解协议的运行原理。为了理解同步、选择、服务发现和数据路径的语义，我们用动态方法补充了静态分析。在本节中，我们将讨论帮助分析该协议的专用macOS日志记录和调试工具。特别是 *Console* 应用，`ioctl` 接口，博通泄漏的 `wl` 组件以及苹果尚未给出文档的 *CoreCapture* 框架。最后一个尤其详细，但是需要我们通过Wireshark进行额外的分析，因为其使用一套私有的数据形结构。

​	**Apple Console**.  自从 macOS10.12 以后，*Console* 就成了最常用的访问日志和内核的debug信息的应用。为了接收到Wi-Fi驱动的详细输出，我们可以在 boot 参数中增加输出日志的等级，这些参数是通过搜索Wi-Fi驱动中对 `PE_parse_boot_arg` 函数的相关引用找到的。在增加日志等级之后，*Console* 会显示额外的信息，例如状态转移和现在的信道序列。

​	**`ioctl` Interface**.  `ioctl` 系统调用是类unix系统中访问设备的标准方式。苹果通过`ioctl`来设置无线设备，如链接AP或创建一个IBSS。Apple为macOS 10.5提供了请求格式、可用请求类型和数据结构的头文件。这些旧的头文件可以使用来自二进制分析的信息更新。`apple8021virtualrequest`方法包含对所有处理函数的调用。在72个可用的请求id中，40个与AWDL相关。这些请求可以在驱动程序中设置几个参数。特别有用的是特定于网卡的ioctl。它允许在Apple ioctl中封装一个Broadcom特定的`ioctl`，为我们提供了一个与Broadcom驱动程序的直接接口。注意，自从苹果修复了我们报告的漏洞(第8节)后，再也不可能发送broadcom特定的`ioctls`：驱动现在需要检查一个私有的授权安全许可\[2\](com.apple.driver.AirPort.Broadcom.ioctl- access)，该许可需要依赖一个苹果私钥签名的二进制文件。通过使用如[16]中的内核扩展补丁框架来覆写对应的权限检查函数以恢复无限制的`ioctl`访问应该是可能的。驱动补丁需要禁用苹果的*System Integrity Protection*.

​	**Broadcom `wl` Utility**.  在博通泄漏的源代码中找到的`wl`组件找到了几种可访问到AWDL工作方式的内部信息的方式，这些都与二进制分析中找到的一些结构体直接相关。尽管泄漏的源码中并没有AWDL特定的驱动代码，`wl` 源码中还是包含AWDL相关的命令和结构体。`wl`可以允许通过`dump awdl`和 `awdl_advertisers`之类的命令来访问现在的AWDL驱动状态。这在之后会显示一些包含RSSI在内的邻节点的信息。

​	**CoreCapture Framework**.  CoreCapture 是苹果在iOS和macOS上对于 IEEE 802.11 标准的主要日志和追踪框架。CoreCapture 结合原始的协议追踪和传统的日志项，提供对于设备和驱动状态的快照。CoreCapture 并未提供文档，但是我们在驱动中找到的 `dumpPacket` 函数有所涉及。由于该框架输出(包括其他日志和内存转储)大量带有自定义头格式的PCAP跟踪文件，所以我们为CoreCapture编写了一个Wireshark剖析器，并将其公开[23]。此外，我们还发布了一本使用本文[22]编写的CoreCapture手册。

### 4. AWDL 概览

​	基于我们的分析，我们制定了关于AWDL设计目标和决策的假设：

1. 利用现有的硬件(Wi-Fi芯片)，从而在IEEE 802.11上构建协议；
2. 节省能源，特别是在流动设备上，因此在空闲时间同步并使Wi-Fi芯片进入省电模式;
3. 要允许直连和基于中间设备的连接的无缝操作，因此要可以在不切断AP连接的前提下进行跳频同步；
4. 实现快速服务发现，从而将DNS-SD传输到Wi-Fi帧。

商用的Wi-Fi芯片通常只有单条RF链，因此在任意时候只能使用一条无线信道。要使用多个信道，适配器需要切换信道，并且不能在短时间内使用常规的无线连接。这是漫游(在连接网络的同时扫描可用的网络)和节能功能(关闭收音机)的预期行为。为了使用这些短时间内的数据传输，设备需要一种方法来发现和协调何时在哪个信道上相遇。我们在图3中描述了AWDL的主要阶段，并在下面简要介绍它们。

![image-20220621163844987](/Users/lunar/Library/Application Support/typora-user-images/image-20220621163844987.png)

**(1) Activation**.  苹果将AWDL用作一项待令的通信技术，这意味着AWDL是默认没有激活的，但是应用将其暂时激活。例如，AirDrop通过发送用户联系信息的截短哈希值来使用BLE进行激活;AirPlay接收器(Apple TV)不断通过AWDL宣布自己的存在;第三方应用程序可以通过`NSNetService` API[6]发布服务来间接激活该接口。

**(2) Master Election**.  苹果使用固定的社交信道(6, 44, 149^[3]^)来协调使用周期性同步帧(PSFs). 一个节点会开启其AWDL接口监控社交信道一段时间来发现其范围内的其它节点。如果节点接收到AWDL Action Frame(AFs)，节点将接受一个已存在的主节点。如果没有接收到Afs，则节点认为自己就是主节点。主节点的选举过程会在6.1节讲述。

**(3) Synchronized Channel Sequences**.  AWDL是围绕一系列时隙(可用性窗口(AWs)和扩展可用性窗口(EAWs))构建的。对于每个窗口，各节点会广播它们是否对AWDL空闲，如果是，则会包括它们所在的信道。各节点用自己的AW序列来匹配这些播报。如果在一个特定的AW中有一个公共信道，在这个AW期间通信是可能的。同步机制使节点之间的序列保持一致。我们在第6.2节和第6.3节分别详细说明了同步和信道对齐过程。

**(4) Service Discovery**.  DNS服务发现(DNS- SD)[18]也被称为“Bonjour”，可以运用到AWDL。AWDL利用DNS-SD直接响应到它的AFs上，这样每当一个节点更改它的播报时，服务就会立即被发现。由于篇幅的原因，我们在本文中没有详细介绍服务发现组件。

**(5) Data Transfer**.  AWDL使用一个特定于供应商的帧，用于专门传输IPv6数据包的用户数据报头。当向特定的对等端传输用户数据时，节点需要计算两个节点调优到同一信道的AWs，并且只在这些AWs中传输帧。此外，AWDL还根据当前的输出流量负载调整其信道序列。在第7节的实验评估中，我们详细讨论了数据传输机制。

### 5. 帧结构

​	我们发现了两种AWDL使用的帧类型：action 和 data 帧，分别用于协调和数据传输。接下来将讲述这些帧的结构。Action Frame 在下文简写为 AF

#### 5.1 Action Frames

​	AWDL使用IEEE 802.11特定于供应商的AF，它通常允许具有组织唯一标识符(Oragnizational Unique Identifer, OUI)的供应商实现具有任意长度[31]的IEEE 802.11帧。AWDL特定于供应商的扩展由一个固定大小的报头和多个TLV字段组成，如图4所示。TLV由一个1字节的 *type* 字段和一个2字节的 *length* 字段组成，该字段表示后面的 *value* 字节字符串的长度。固定的报头主要包括静态值，如AWDL特定的BSSID、OUI、版本和类型。有两个时间戳指示了帧创建的时间，在这个时间包括的信息是最新的($T_{\mathrm{Tx, Target}}$)，以及它实际排队传输的时间($T_{\mathrm{Tx,PHY}}$)。两个时间之差近似于发送方的传输延迟，可以用于同步。AWDL AF有两种子类型:周期同步帧(PSF)和主指示帧(MIF)。这些帧类型以相同的固定报头开始，只在包含的tlv集合和它们的大小上有所不同。我们在图4中展示了不包括帧末FCS的帧格式。我们首先解释子类型的目的，然后讨论AWDL中使用的tlv。

​	![image-20220621194005768](/Users/lunar/Library/Application Support/typora-user-images/image-20220621194005768.png)

**Periodic Synchronization Frame(PSF)**.  PSF 帧用于同步，在6.2 节有进一步的解释。这个名字来自于一个专利[33]。其对应的 *subtype* 值为0。

**Broadcast Master Indication Frame(MIF)**.  MIF帧有多种用途，选举和服务发现。

**TLVs**.  TLVs 包含了实际的控制信息。不同的类型可以用于下列用途：选举和同步（*election and synchronization*)、服务发现(*service discovery*)、用户数据传输(*user data transmission*)。此外，1字节的 *version* TLV 推测用于取代固定头的版本号。我们在下表中总结了所有的TLV 并在下文进行了简短的讨论。注意一些 *type* 值是缺失的，这表明在我们分析时这些 *type* 已经不再使用。

![image-20220621200632338](/Users/lunar/Library/Application Support/typora-user-images/image-20220621200632338.png)

​	*election and synchronization* 进程负责处理所有的设备互连。这些TLV中的值决定了哪个节点充当主节点的角色以及用哪些信道。奇怪的是，Synchronization Parameter TLV 已经包含了信道序列，这使得 Channel Sequence TLV 显得有些多余。然而，它总是在当前的操作系统版本上传输。这将在第6.1至6.3节中进一步讨论。*Service Discovery* 组件将mDNS和DNS-SD功能提供给AF。它们包含主机名(Arpa TLV);PTR、SRV和TXT资源记录(Service Response TLV)。*user data transmission* 组件负责为设备间直连沟通参数。例如，支持的PHY速率是在HT/VHT Capabilities TLV 中宣布的，与IEEE 802.11 n和11 ac修正[31]中引入的类似。此外，每个节点在 Data Path State TLV中宣布其当前连接的Wi-Fi网络(BSSID)以及Wi-Fi芯片的真实MAC地址。我们认为如果两个节点都连接到相同的网络，该信息可以用于将AWDL连接加载到基础设施网络。然而，由于网络策略(如客户端隔离)的原因，这将需要额外的可达性测试，而在实践中我们并没有观察到这种行为。*version* TLV包括AWDL版本号(主版本号和副版本号各半个字节)以及设备类ID。我们发现 v3.x 用于macOS 10.13和iOS 11; 而v2.x用于macOS 10.12和iOS 10(可能更早的iOS版本)。AWDL v1.x用于macOS 10.11，其不支持 *version* TLV。设备类似乎表明节点的操作系统类型，例如，macOS(1)或iOS(2)。

#### 5.2 Data Frames

​	AWDL 使用 IEEE 802.11 数据帧来进行用户数据的传输。与IBSS类似，to - ds和From-DS标志设置为0，这意味着这些帧是直接寻址的，三个地址字段用于目的地址、源地址和BSSID。我们在图5中描述了AWDL数据帧格式。AWDL帧中的BSSID总是00:25:00:ff:94:73，它属于被分配给Ap[20]的OUI 00:25:00。LLC头包含一个不同的Apple OUI (00:17:f2)和SNAP部分的协议ID。这些协议头是IEEE 802标准[30]的一部分，允许供应商在更高的层上实现他们自己的协议。实际的AWDL数据头基本上由一个序列号和传输协议的EtherType组成。我们确定IPv6是AWDL使用的唯一协议。

#### 5.3 Addressing for Higher-Layer Protocols

​	AWDL 可用于连接更高层的协议。因此，其需要一些方法通过网络层协议给AWDL节点赋地址。这一点尤其重要，因为AWDL实现了隐私增强的随机MAC地址，这意味着每次AWDL接口被激活时，其使用一个随机生成的MAC地址而不是Wi-Fi芯片上的固定MAC地址。在IPv6中，地址解析通常通过Neighbor Discovery Protocol（NDP）协议完成。然而，Apple并没有对AWDL使用NDP，而是使用RFC 4291[19，附录a]中描述的方法从AFs中包含的源地址字段(图4)生成链路本地IPv6地址。该方法利用网络接口的48位MAC地址构造一个链路本地IPv6地址。其中，给定一个48位MAC地址o0:o1:o2:o3:o4:o5，对应的链路本地IPv6地址构造为:

`Fe:80::o0 ^0x02:o1:o2:ff: Fe:o3:o4:o5`

使用这种标准化的方法，节点可以在收到第一个AF后立即将邻节点添加到邻居表中，而不需要额外的地址解析协议(如NDP或ARP)，也不需要额外的开销。

### 6. Protocol Operation

​	在本章将具体展示如何组建和维护一个AWDL群组。重点是讨论如何选举一个主节点，以及如何解决冲突；各节点如何与主节点保持时钟同步；以及如何将公布的信道序列映射到可用窗口AW序列。

#### 6.1 Master Election

**Role of the Master Node**.  如上文所说，AWDL的运行依赖于群组中所有参与节点的大致的时钟同步。为了做到这点，最重要的是需要有一个节点来输出时钟信号。这就是主节点的主要工作。在一些较大的场景中，从节点可能距离主节点超过一跳(hop)的距离，这种情况下，中间的从节点就成为了非选举主节点(*non-election masters*)，负责重复主节点的时钟信号。中间节点包括在了 Synchronization Tree TLV中，其中每个节点都公开了到达主节点的路径。

**Master Metric**.  主节点的选举是基于 *metric* 域的，其包含在 Election Parameters v2 TLV 中。宣称有最大 *metric* 的节点就是主节点。苹果的专利[34]声称，这些 *metric* 可以基于可用的能源资源、CPU负载、信号强度等。然而，在实践中，*metric* 只是随机选择的。激活AWDL接口的节点最初将其度量字段设置为60，并在社交渠道上侦听现有主节点，时间为2秒。如果没有找到master，它会从预定义的范围中抽取一个随机数，并将其设置为 *metric*。我们发现这个范围取决于AWDL的版本，例如，在v2中的405到436。X和505到536在v3.x。我们假设这样做是为了向后兼容，从而保证主节点是集群中运行最新版本的节点，并且可以支持未来的协议扩展。

**Merging Clusters with Different Masters**.  当两个已经建立并有着不同主节点的AWDL群组靠近时，它们需要融合以确保两个群组的节点都能发现彼此。在AWDL中，这一过程是很直观的。两个群组的节点都互相播报现在主节点的metric，然后 metric 更低的主节点就自动成为从节点，其群组也自动并入另一个群组。

**Loop Prevention**.  当创建这样一个有着多层亚-主节点的选举树制度时，可能会产生环路。为了避免环路以及限制选举树的最大深度，每个AF都包含到达顶端节点（注：顶端节点可能是主节点也可能是亚-主节点）的所有节点。这样对于每个节点，如果其已经在一个非选举主节点的路径内的话，就不会重新接受该节点。

**Re- Election**.  当新设备加入网络时，使用低metric的设备初始化将防止大多数随机的重新选举。由于没有结束消息，离开网络的主节点只会停止发送AF。因此，一个丢失的主节点只有在一定的无主节点(*no master*)超时时间(固定为96 AWs≈1.5 s)后，其他设备才能检测到，然后由另一个节点取代原来的主节点。由于此节点已经与旧主节点同步，其他从节点不需要重新同步，而只需采用新的主节点。换句话说，AWDL对“主节点流失”是稳健的，也就是说，一个离开的主节点不中断通信，一个新的主节点被无缝地采用。这与Wi-Fi 直连等其他技术相反，在这些技术中，各自的主节点实际上充当AP，负责两个节点之间的数据中继，而离开的主节点将需要重新建立一个组。

**The Role of RSSI**.  接收到的AF的RSSI值用来过滤掉可能不稳定的连接。特别是，当RSSI低于所谓的被设置为-65(或-78如果使用AirPlay)的边缘同步阈值时，AWDL节点会丢弃帧。来自当前主节点的帧以较低的RSSI被接受。这些帧包含一个额外的值为5的 *slave sync* 阈值。降低主帧的阈值允许RSSI有一定的差异。我们假设这样做是为了减少“主节点振荡”，否则一个节点会频繁地采用一个新的主节点，因为它经常丢弃帧，并且 *no master* 超时发生。

#### 6.2 Synchronization

​	同步与选举过程紧密耦合，因为节点总是试图与它们选举的主节点同步。在本节中，我们将描述AWDL中时间的结构，以及节点如何将它们的时间引用与其主节点的时间引用对齐。我们引入了可用性窗口(Availability Windows, AWs)的概念，即短的固定长度的时隙，在此期间通信是可能的。这些窗口有一个静态长度，但是可以使用扩展窗口(Extension Windows, EWs)进行扩展。最后，我们展示了如何使用同步参数TLV中的字段来确定AW的开始。我们在图7中总结了关键的概念和变量。

![image-20220622102628191](/Users/lunar/Library/Application Support/typora-user-images/image-20220622102628191.png)

**Availability Window**.  AW代表一段设备可以通信的空闲时间。这些窗口需要对于群组内所有的节点都进行同步，这样每个节点才能同时发起一个AW。AWDL的计时基于 Time Units，1TU = 1024 $\mu$s。在AWDL实现中，一个AW总是被设置为16 TUs长。一个AW的长度和所有其他“静态”值在本节中都包含在同步参数TLV中。理论上，不同的配置是可能的，但我们发现只使用固定的值。

**Presence Mode and Extension Windows**.  为了减少功耗，节点可以表明它并没有监听每一个AW。存在模式(presence mdoe) *p* 为4，这是Apple AWDL实现中使用的唯一值，意味着一个节点只侦听每四个窗口。如果一个节点正在传输或接收数据，它可能会延长它在信道上花费的时间。这被称为扩展窗口(EW)。存在模式为4时，剩余空间为3个16 TU的EW。此外，AWDL允许配置单播、组播和AF EW的不同编号，但这些字段目前总是设置为3，从而与存在模式保持一致。图6显示了同步参数TLV中传输的参数。对于静态配置，有效的最小使用时间单位是四个连续的AW/EW。在本文的剩余部分，我们使用扩展可用性窗口(EAW)来指代这样一个64 TU的时点。

**Calculating the Start of an Availability Window**.  每个从节点都需要将自己的时钟同步到主节点。为了实现这一点，主节点宣布下一个AW的开始。在发送AF时，包括了距离下一个 EAW $t_{\mathrm{AW}}$ 的TU数量和现在 AW 或 EW 的序列号 $i$。在图7中标识了这些数值。

​	当在驱动程序中创建帧时设置这些值，一段时间后帧才通过Wi-Fi接口传输。AWDL试图通过在每个AF的固定报头中包括两个额外的时间戳来补偿这种发送延迟: PHY时间和目标传输时间 $T_{\mathrm{Tx,PHY}}$和 $T_{\mathrm{Tx,Target}}$。通常，$T_{\mathrm{Tx,Target}}$是在帧创建时设置的，$T_{\mathrm{Tx,PHY}}$是在帧通过接口传输之前设置的。然而，在macOS驱动程序中，两个时间戳都是在Wi-Fi驱动程序中设置的，因此，没有考虑到由控制介质访问[31]的分布式协调函数(DCF)引起的延迟。然而，一台设备在时间 $T_{\mathrm{Rx}}$ 接收到其主节点时，可以通过下面的方法估计下一个AW时间 $T_{\mathrm{AW}}$:
$$
T_{\mathrm{AW}} = t_{\mathrm{AW}}\cdot1024 - (T_{\mathrm{Tx,PHY}}-T_{\mathrm{Tx,Target}})+ t_{\mathrm{air}}+ T_{\mathrm{Rx}}\tag{1}
$$
​	在典型的近距离Wi-Fi场景中，AWDL是sub-μs量级，因此AWDL忽略了空时误差，可接受的同步误差为3 ms^[4]^。

#### 6.3 Channel Sequence

​	AWDL信道序列公告建立在同步AW的基础上，并指示节点是否实际可用于通信，如果是，则指示它在哪个信道。在本节中，我们将解释信道序列如何映射到AW序列。

​	道序列将信道号映射到AW序列号。图8所示的TLV中包含的信道序列包含固定数量的c + 1 = 16个信道项，但该序列可以通过 *step* 字段延长，类似于存在模式，使一个信道条目可以跨越多个AW和EW将step设置为1意味着信道将为一个额外的AW激活。然而，苹果总是将该字段设置为3，这意味着信道将为四个AW或一个EAW激活。因此，信道序列完全与同步参数TLV中的存在模式对齐。给定一个已编码的信道序列和一个AW序列号 $i$, AWDL节点可以根据以下计算方法计算任意对等点当前活动的信道 *C*:
$$
C = i\quad \mathrm{mod}\ ((c+1)\cdot(step+1))\tag{2}
$$
由于苹果使用固定的 *c* 和 *step* 值，因此公布的信道序列覆盖了 $(15+1)\cdot(3+1)=64$ 个AW，消耗的时间大概为1s。

